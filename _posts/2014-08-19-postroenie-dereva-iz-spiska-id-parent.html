---
layout: post
status: publish
published: true
title: Построение дерева из списка ID-Parent
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 566
wordpress_url: http://devdocs.ru/?p=5
date: '2014-08-19 21:14:12 +0300'
date_gmt: '2014-08-19 21:14:12 +0300'
categories:
- PHP
tags:
- php
- ui
comments: []
---
<p>Поскольку данная задача возникает у разработчиков довольно часто, хотел бы поделиться простым и эффективным решением. Всё, что нам потребуется &mdash; это исходный массив примерно такого вида:</p>
<blockquote>
<pre class="brush: php; gutter: true">$listIdParent = array(<br />
  1 => array(&#039;parent&#039; => 0),<br />
  2 => array(&#039;parent&#039; => 1),<br />
  3 => array(&#039;parent&#039; => 1),<br />
  4 => array(&#039;parent&#039; => 2),<br />
  5 => array(&#039;parent&#039; => 4)<br />
);<&#47;pre><br />
<&#47;blockquote><br />
<span id="more-183"><&#47;span><br />
Как нетрудно догадаться, ключи исходного списка являются ID, а поля parent содержат ссылки на родительский элемент в дереве. Элемент с parent, равным 0, является корневым. Такой элемент должен быть единственным в списке, и в целом дерево должно быть консистентным (не должно быть &laquo;битых&raquo; ссылок и рекурсивной вложенности) &mdash; и, пожалуй, это единственные ограничения. Таким образом, важной особенностью используемого метода является то, что элементы исходного списка могут идти в любом порядке, в отличие от известного способа с array_pop(), который требует, чтобы элементы были отсортированы по уровню (глубине вложенности).</p>
<p>Дерево строится следующей функцией:</p>
<blockquote>
<pre class="brush: php; gutter: true">&#47;**<br />
 * Построение дерева из списка ID-Parent.<br />
 *<br />
 * @param array Исходный список.<br />
 * @return array Дерево.<br />
 *&#47;<br />
function buildTree(array $listIdParent) {<br />
  &#47;&#47; Подготовка ID корневого узла.<br />
  $rootId = 0;</p>
<p>  &#47;&#47; Обход списка и обработка узлов.<br />
  foreach ($listIdParent as $id => $node) {<br />
    if ($node[&#039;parent&#039;]) {<br />
      &#47;&#47; Сохранение в родительском узле ссылки на текущий.<br />
      $listIdParent[$node[&#039;parent&#039;]][&#039;sub&#039;][$id] =&amp; $listIdParent[$id];<br />
    } else {<br />
      &#47;&#47; Сохранение ссылки на корневой элемент.<br />
      $rootId = $id;<br />
    }<br />
  }</p>
<p>  &#47;&#47; Возврат корневого узла, содержащего всё построенное дерево.<br />
  return array($rootId => $listIdParent[$rootId]);<br />
}<br />
<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script><&#47;pre><br />
<&#47;blockquote><br />
Для повышения удобочитаемости в коде функции опущены необходимые проверки входного массива на корректность.</p>
<p>Результат работы функции выглядит так:</p>
<blockquote>
<pre class="brush: php; gutter: true">array(<br />
  1 => array(<br />
    &#039;parent&#039; => 0,<br />
    &#039;sub&#039; => array(<br />
      2 => array(<br />
        &#039;parent&#039; => 1,<br />
        &#039;sub&#039; => array(<br />
          4 => array(<br />
            &#039;parent&#039; => 2,<br />
            &#039;sub&#039; => array(<br />
              5 => array(&#039;parent&#039; => 4)<br />
            )<br />
          )<br />
        )<br />
      ),<br />
      3 => array(<br />
        &#039;parent&#039; => 1<br />
      )<br />
    )<br />
  )<br />
)<br />
<&#47;pre><br />
<&#47;blockquote><br />
При сравнении с другими способами построения дерева из списка ID-Parent можно выделить следующие основные моменты:</p>
<ol>
<li>отсутствие рекурсии;<&#47;li>
<li>достаточно одной функции;<&#47;li>
<li>всего один цикл по исходному массиву для полного построения дерева;<&#47;li>
<li>все манипуляции с массивом заключаются в установке ссылок на дочерние элементы, что сильно экономит память и увеличивает быстродействие (по сравнению с методами, перемещающими сами элементы массива).<&#47;li><br />
<&#47;ol><br />
И хотя первые два пункта так же присущи алгоритму с array_pop(), третий пункт, а также меньшие ограничения на формат входного массива делают предложенное решение наиболее применимым в разработке.</p>
