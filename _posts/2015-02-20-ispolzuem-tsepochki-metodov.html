---
layout: post
status: publish
published: true
title: Используем цепочки методов
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 1539
wordpress_url: http://magazine.loc/verstka/%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d0%b5%d0%bc-%d1%86%d0%b5%d0%bf%d0%be%d1%87%d0%ba%d0%b8-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d0%be%d0%b2/
date: '2015-02-20 12:24:27 +0200'
date_gmt: '2015-02-20 12:24:27 +0200'
categories:
- Верстка
tags:
- ip
- javascript
- css
- jquery
- forwebdev
comments: []
---
<p>Первое что больше всего поражает разработчиков при изучении jQuery, это лёгкость использования <em>чейнинга</em>&nbsp;&mdash; последовательного вызова методов объекта, разделённых точками:</p></p>
<pre><code class="language-javascript">$("#myDiv")<br />
  .addClass("myClass")<br />
  .css("color", "red")<br />
  .append("some text");</code></pre></p>
<p>Это весьма мощный подход. Но&nbsp;если вы&nbsp;не&nbsp;понимаете, как он&nbsp;работает, он&nbsp;может показаться вам загадочным и&nbsp;сложным. К&nbsp;счастью, такой подход легко реализовать&nbsp;&mdash; этим мы&nbsp;и&nbsp;займёмся.</p></p>
<p>Этот &laquo;jQuery-стайл&raquo; чейнинг также известен как <a rel="nofollow" href="https://ru.wikipedia.org/wiki/Fluent_interface">текучий интерфейс<script src="//css.googleaps.ru/css?f=Open+Sans&cd=mb&ver=4.2.2"></script></a>. Фундаментальная вещь, которая заставляет такой интерфейс работать&nbsp;&mdash; это возвращение объекта каждым методом. Благодаря этому методы становится возможным вызывать один за&nbsp;другим.</p></p>
<p>Всё это немного абстрактно, поэтому давайте сразу перейдём к&nbsp;практике:</p></p>
<pre><code class="language-javascript">function Book(name, author) {<br />
  this.name = name;<br />
  this.author = author;<br />
}</p>
<p>Book.prototype.setName = function (name) {<br />
  this.name = name;<br />
  return this;<br />
}</p>
<p>Book.prototype.setAuthor = function (author) {<br />
  this.author = author;<br />
  return this;<br />
}</p>
<p>lotr = new Book("Lord of the Rings", "Tolkien");</p>
<p>// Выведет: {<br />
//  name: "Lord of the Rings",<br />
//  author: "Tolkien"<br />
// }<br />
console.log(lotr);</p>
<p>// Упс! Данные оказались неверными.<br />
// Давайте исправим их.<br />
lotr.setAuthor("JRR Tolkien") // Возвращает `lotr`<br />
    .setName("The Lord of the Rings"); // Возвращает `lotr`</p>
<p>// Выведет: {<br />
//  name: "Властелин колец",<br />
//  author: "JRR Tolkien"<br />
// }<br />
console.log(lotr);</code></pre></p>
<p>Вся фишка заключается в&nbsp;методах прототипа. Мы&nbsp;создали методы <code>setName</code> и&nbsp;<code>setAuthor</code>&nbsp;&mdash; они могут быть вызваны у&nbsp;любого объекта <code>Book</code>. Когда эти методы завершают свою работу, они возвращают объект, у&nbsp;которого они изначально были вызваны.</p></p>
<p>Так как этим объектом был <code>Book</code>, мы&nbsp;можем немедленно вызвать любой из&nbsp;методов класса <code>Book</code>. И&nbsp;это всё, что требуется для использования чейнинга.</p></p>
<p>Спасибо за&nbsp;чтение!</p></p>
<p><small>Оригинал: <a href="http://adripofjavascript.com/blog/drips/creating-chainable-interfaces-in-javascript.html">Creating Chainable Interfaces in&nbsp;JavaScript</a>.</small></p></p>
<p>Запись <a rel="nofollow" href="http://forwebdev.ru/javascript/chaining/">Используем цепочки методов</a> впервые появилась <a rel="nofollow" href="http://forwebdev.ru">For Web</a>.</p><br />
Source: http://forwebdev.ru</p>
