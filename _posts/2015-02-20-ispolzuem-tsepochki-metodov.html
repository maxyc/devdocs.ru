---
layout: post
status: publish
published: true
title: Используем цепочки методов
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 1539
wordpress_url: http://magazine.loc/verstka/%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d0%b5%d0%bc-%d1%86%d0%b5%d0%bf%d0%be%d1%87%d0%ba%d0%b8-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d0%be%d0%b2/
date: '2015-02-20 12:24:27 +0200'
date_gmt: '2015-02-20 12:24:27 +0200'
categories:
- Верстка
tags:
- ip
- javascript
- css
- jquery
- forwebdev
comments: []
---
<p>Первое что больше всего поражает разработчиков при изучении jQuery, это лёгкость использования <em>чейнинга<&#47;em>&nbsp;&mdash; последовательного вызова методов объекта, разделённых точками:<&#47;p></p>
<pre><code class="language-javascript">$("#myDiv")<br />
  .addClass("myClass")<br />
  .css("color", "red")<br />
  .append("some text");<&#47;code><&#47;pre></p>
<p>Это весьма мощный подход. Но&nbsp;если вы&nbsp;не&nbsp;понимаете, как он&nbsp;работает, он&nbsp;может показаться вам загадочным и&nbsp;сложным. К&nbsp;счастью, такой подход легко реализовать&nbsp;&mdash; этим мы&nbsp;и&nbsp;займёмся.<&#47;p></p>
<p>Этот &laquo;jQuery-стайл&raquo; чейнинг также известен как <a rel="nofollow" href="https:&#47;&#47;ru.wikipedia.org&#47;wiki&#47;Fluent_interface">текучий интерфейс<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script><&#47;a>. Фундаментальная вещь, которая заставляет такой интерфейс работать&nbsp;&mdash; это возвращение объекта каждым методом. Благодаря этому методы становится возможным вызывать один за&nbsp;другим.<&#47;p></p>
<p>Всё это немного абстрактно, поэтому давайте сразу перейдём к&nbsp;практике:<&#47;p></p>
<pre><code class="language-javascript">function Book(name, author) {<br />
  this.name = name;<br />
  this.author = author;<br />
}</p>
<p>Book.prototype.setName = function (name) {<br />
  this.name = name;<br />
  return this;<br />
}</p>
<p>Book.prototype.setAuthor = function (author) {<br />
  this.author = author;<br />
  return this;<br />
}</p>
<p>lotr = new Book("Lord of the Rings", "Tolkien");</p>
<p>&#47;&#47; Выведет: {<br />
&#47;&#47;  name: "Lord of the Rings",<br />
&#47;&#47;  author: "Tolkien"<br />
&#47;&#47; }<br />
console.log(lotr);</p>
<p>&#47;&#47; Упс! Данные оказались неверными.<br />
&#47;&#47; Давайте исправим их.<br />
lotr.setAuthor("JRR Tolkien") &#47;&#47; Возвращает `lotr`<br />
    .setName("The Lord of the Rings"); &#47;&#47; Возвращает `lotr`</p>
<p>&#47;&#47; Выведет: {<br />
&#47;&#47;  name: "Властелин колец",<br />
&#47;&#47;  author: "JRR Tolkien"<br />
&#47;&#47; }<br />
console.log(lotr);<&#47;code><&#47;pre></p>
<p>Вся фишка заключается в&nbsp;методах прототипа. Мы&nbsp;создали методы <code>setName<&#47;code> и&nbsp;<code>setAuthor<&#47;code>&nbsp;&mdash; они могут быть вызваны у&nbsp;любого объекта <code>Book<&#47;code>. Когда эти методы завершают свою работу, они возвращают объект, у&nbsp;которого они изначально были вызваны.<&#47;p></p>
<p>Так как этим объектом был <code>Book<&#47;code>, мы&nbsp;можем немедленно вызвать любой из&nbsp;методов класса <code>Book<&#47;code>. И&nbsp;это всё, что требуется для использования чейнинга.<&#47;p></p>
<p>Спасибо за&nbsp;чтение!<&#47;p></p>
<p><small>Оригинал: <a href="http:&#47;&#47;adripofjavascript.com&#47;blog&#47;drips&#47;creating-chainable-interfaces-in-javascript.html">Creating Chainable Interfaces in&nbsp;JavaScript<&#47;a>.<&#47;small><&#47;p></p>
<p>Запись <a rel="nofollow" href="http:&#47;&#47;forwebdev.ru&#47;javascript&#47;chaining&#47;">Используем цепочки методов<&#47;a> впервые появилась <a rel="nofollow" href="http:&#47;&#47;forwebdev.ru">For Web<&#47;a>.<&#47;p><br />
Source: http:&#47;&#47;forwebdev.ru</p>
