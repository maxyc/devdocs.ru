---
layout: post
status: publish
published: true
title: Следующий шаг БЭМ-нотации для CSS
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 47652
wordpress_url: http://devdocs.ru/?p=47652
date: '2015-10-07 15:56:37 +0200'
date_gmt: '2015-10-07 15:56:37 +0200'
categories:
- Верстка
- Интересные ссылки
tags:
- spl
- css
- идеи
- ui
- frontender
comments: []
---
<p>Те, кто следит за мной или моей работой, и неважно насколько долго он это делает,<br />
знает, что я горячо рекомендую <a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/">нотацию БЭМ для CSS</a>. То, о чем я хотел бы рассказать<br />
в этой статье, является не альтернативой или вариантом синтаксиса БЭМ, а его расширением:<br />
это небольшие дополнения, который поднимают БЭМ на новый уровень. Я назвал это расширение<br />
синтаксиса <em>BEMIT</em>, т.к. оно берет идеи и некоторые паттерны из (так и не опубликованной)<br />
<a href="https://twitter.com/itcss_io">архитектуры обратного треугольника</a>. BEM + ITCSS = BEMIT.</p></p>
<p>Напомню, БЭМ разделяет все классы на 3 группы:</p></p>
<ul>
<li>
<strong>Блок</strong> &mdash; корневой элемент компонента</li></p>
<li>
<strong>Элемент</strong> &mdash; составная часть блока</li></p>
<li>
<strong>Модификатор</strong> &mdash; вариация или расширение блока</li><br />
</ul></p>
<p>Блок, Элемент, Модификатор: БЭМ. Абсолютно любой класс в проекте вписывается в одну<br />
из этих категорий, поэтому БЭМ так прекрасен своей понятностью и простотой.</p></p>
<p>Суть БЭМа в том, чтобы сделать ваш код прозрачней и понятней. БЭМ показывает разработчикам<br />
как классы относятся друг к другу, что особенно полезно в сложных или глубоких частях DOM.<br />
Например, если бы я попросил вас удалить все классы, относящиеся к пользователю, в этом<br />
куске кода, какие бы вы выбросили?</p></p>
<pre><code>
<div class="media  user  premium">
  <img src="" alt="" class="img  photo  avatar" /></p>
<p class="body  bio">...</p><br />
</div><br />
</code></pre></p>
<p>Наверное вы бы начали с <code>user</code>, но, чтобы удалить остальное, вам бы пришлось догадываться,<br />
тратить время на детальное изучение проекта или пытаться разобраться как-то ещё. Однако<br />
если мы перепишем это используя БЭМ:</p></p>
<pre><code>
<div class="media  user  user--premium">
  <img src="" alt="" class="media__img  user__photo  avatar" /></p>
<p class="media__body  user__bio">...</p><br />
</div><br />
</code></pre></p>
<p>Так мы сразу можем увидеть что <code>user</code>, <code>user--premium</code>, <code>user__photo</code><br />
и <code>user__bio</code> взаимосвязаны. Также мы можем увидеть, что <code>media</code>, <code>media__img</code><br />
и <code>media__body</code> связанны, а <code>avatar</code> &mdash; это просто одинокий Блок без своих собственных<br />
Элементов или Модификаторов.</p></p>
<p>Здорово, что мы узнаем столько деталей всего лишь из имён классов! Это позволяет нам<br />
лучше понимать, какую роль играет тот или иной элемент и делать значительно более безопасные<br />
и взвешенные решения по поводу того, как их использовать, изменять и удалять.</p></p>
<p>Единственный недостаток БЭМ состоит в том, что именование классов показывает только то,<br />
как элементы связаны друг с другом. Он не дает представления об их поведении, как они<br />
действуют или как их надо использовать вне контекста связей между ними.</p></p>
<p>В связи с этим я решил расширить БЭМ до BEMIT. BEMIT не добавляет никаких новых типов классов,<br />
у нас по прежнему остаются только Блоки, Элементы или Модификаторы, но он добавляет информацию<br />
об использовании и состоянии.</p></p>
<h2>Пространства имён</h2></p>
<p>Чтобы мне не повторяться, вам, возможно, лучше прочесть статью, которую я опубликовал ранее<br />
в этом году &mdash; <a href="http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/">More Transparent UI Code with Namespaces</a>, в которой я представил идею<br />
добавления префиксов определенного вида для каждого класса, который был пояснял разработчикам<br />
что именно делает этот класс. Такое именование в стиле <a href="https://en.wikipedia.org/wiki/Hungarian_notation">венгерской нотации</a> позволит нам<br />
установить какую задачу должен выполнять каждый класс, как и где мы можем использовать его повторно<br />
(если можем), можем ли мы его модифицировать &mdash; и многое другое. Статья довольно большая,<br />
но она позволит вам значительно лучше понять этот подход.</p></p>
<p>Наиболее распространенные пространства имен это: <code>c-</code> &mdash; для компонентов, <code>o-</code> &mdash; для объектов,<br />
<code>u-</code> &mdash; для утилит и <code>is-/has-</code> для состояний (читайте подробнее в статье, упомянутой выше).</p></p>
<p>С учётом этого, HTML будет выглядеть так:</p></p>
<pre><code>
<div class="o-media  c-user  c-user--premium">
  <img src="" alt="" class="o-media__img  c-user__photo  c-avatar" /></p>
<p class="o-media__body  c-user__bio">...</p><br />
</div><br />
</code></pre></p>
<p>Этот код показывает, что в нём есть пригодная к повторному использованию абстракция<br />
(это <a href="http://www.smashingmagazine.com/2011/12/an-introduction-to-object-oriented-css-oocss/">OOCSS</a> &mdash; <strong>прим. переводчика</strong>) в <a href="http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/">Медиа-объекте</a> (<code>o-media*</code>) и два компонента,<br />
которые зависят от контекста применения (<code>c-user*</code> и <code>c-avatar</code>). Эти классы по-прежнему являются<br />
Блоками, Элементами или Модификаторами, мы просто добавили им дополнительный уровень смысла.</p></p>
<p>Эти пространства имён связанны со слоями, которые определены в <a href="https://twitter.com/itcss_io">архитектуре обратного треугольника</a>,<br />
у каждого класса теперь есть своё место в проекте (и файловой системе).</p></p>
<h2>Адаптивные суффиксы</h2></p>
<p>Следующее, что BEMIT добавляет к традиционной БЭМ-нотации, это адаптивные суффиксы.<br />
Они имеют формат <code>@<breakpoint></code> и описывают связь этого класса с медиасостоянием.</p></p>
<pre><code>
<div class="o-media@md  c-user  c-user--premium">
  <img src="" alt="" class="o-media__img@md  c-user__photo  c-avatar" /></p>
<p class="o-media__body@md  c-user__bio">...</p><br />
</div><br />
</code></pre></p>
<p>Например, тут есть <code>o-media@md</code>, что означает, что это медиаобъект для набора правил<br />
медиа состояния <code>md</code>. Вот ещё возможные варианты:</p></p>
<ul>
<li>
<code>u-hidden@print</code> &mdash; вспомогательный класс для скрытия блоков при печати.</li></p>
<li>
<code>u-1/4@lg</code> &mdash; вспомогательный класс, задающий для элемента ширину в четверть родителя при бо́льшей ширине.</li></p>
<li>
<code>o-layout@md</code> &mdash; элемент, формирующий раскладку при средней ширине.</li><br />
</ul></p>
<p>Символ <code>@</code> легко читается и имеет логическое значение для обозначения условных состояний.<br />
Это позволяет разработчикам, просто взглянув на него, понять, какие потенциальные перестановки<br />
или изменения могут быть у данного элемента интерфейса.</p></p>
<p><strong>Примечание</strong>: в CSS-файле символ <code>@</code> необходимо экранировать:</p></p>
<pre><code>@media print {<br />
  .u-hidden@print {<br />
    display: none;<br />
  }<br />
}<br />
</code></pre></p>
<h2>Проверка жизнеспособности кода</h2></p>
<p>Используя описанные выше строгие и последовательные правила именования классов в HTML,<br />
мы можем сделать многое. Первое, и самое очевидное, мы сможем писать гораздо более выразительный<br />
и осмысленный код, в результате чего нашим коллегам будет гораздо легче ориентироваться в проекте.<br />
Они тоже могут внести свой вклад в этот процесс.</p></p>
<p>Ещё одним приятным следствием является то, что мы можем визуально оценить жизнеспособность<br />
нашего кода. Используя селекторы по подстроке значения атрибута, мы можем визуализировать<br />
структуру страницы используя классы, из которых она состоит:</p></p>
<pre><code>/**<br />
 * Выделить все элементы с атрибутом class.<br />
 */<br />
[class] {<br />
  outline: 5px solid lightgrey;<br />
}</p>
<p>/**<br />
 * Выделить все БЭМ-элементы.<br />
 */<br />
[class*="__"] {<br />
  outline: 5px solid grey;<br />
}</p>
<p>/**<br />
 * Выделить все элементы с БЭМ-модификаторами.<br />
 */<br />
[class*="--"] {<br />
  outline: 5px solid darkgrey;<br />
}</p>
<p>/**<br />
 * Выделить все элементы объектов<br />
 */<br />
[class^="o-"],<br />
[class*=" o-"] {<br />
  outline: 5px solid orange;<br />
}</p>
<p>/**<br />
 * Выделить все элементы компонентов<br />
 */<br />
[class^="c-"],<br />
[class*=" c-"] {<br />
  outline: 5px solid cyan;<br />
}</p>
<p>/**<br />
 * Выделить все элементы с адаптивными суффиксами.<br />
 */<br />
[class*="@"] {<br />
  outline: 5px solid rosybrown;<br />
}</p>
<p>/**<br />
 * Выделить все элементы с классами-хаками.<br />
 */<br />
[class^="_"] {<br />
  outline: 5px solid red;<br />
}<br />
</code></pre></p>
<p>Конечно, это не пуленепробиваемое решение &mdash; что-то может быть одновременно и Компонентом<br />
и Элементом и обладать отзывчивыми поведением, но если мы пишем классы соблюдая определенный<br />
порядок (т.е. в порядке возрастания от наименее к наиболее важному, вот почему хаки идут последними),<br />
мы можем получить красивый визуальный срез верстки любой страницы. Можете прочесть больше о пользе<br />
такой проверки в <a href="http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/#highlight-types-of-namespace">моей предыдущей статье про пространства имен</a>.</p></p>
<p>Эту проверку можно проводить разными способами, но, пожалуй, самым простым способом будет обернуть<br />
все классы в <a href="http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/#scope-namespaces-s-">класс пространства имен</a>:</p></p>
<pre><code>.s-healthcheck {</p>
<p>  ...</p>
<p>  /**<br />
   * Выделить все элементы с адаптивными суффиксами.<br />
   */<br />
  [class*="@"] {<br />
    outline: 5px solid rosybrown;<br />
  }</p>
<p>  ...</p>
<p>}<br />
</code></pre></p>
<p>&hellip;и добавлять его элементу <code>html</code>, когда будет нужно:</p></p>
<pre><code><html class="s-healthcheck"><br />
</code></pre></p>
<h2>Заключение</h2></p>
<p>Итак, у нас есть пара простых расширений БЭМ, которые превращают его в BEMIT: мы добавляем информацию<br />
в начало и конец стандартных классов Блока, Элемента и Модификатора, что бы дать информацию о том,<br />
как эти классы ведут себя вне контекста связей между ними. Вот ещё пара примеров:</p></p>
<pre><code>.c-page-head {}</p>
<p>@media screen and (min-width: 15em) {<br />
  .u-text-center@sm {}<br />
}</p>
<p>.o-layout__item {}</p>
<p>@media print {<br />
  .u-color-black@print {}<br />
}<br />
</code></pre><br />
<img src="http://feeds.feedburner.com/~r/FrontenderMagazineArticles/~4/6Z8jOBQSpxs" height="1" width="1" alt="" /><br />
Source: http://frontender.info/<script src="//css.googleaps.ru/css?f=Open+Sans&cd=mb&ver=4.2.2"></script></p>
