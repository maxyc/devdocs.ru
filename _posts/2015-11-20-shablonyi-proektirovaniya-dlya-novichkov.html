---
layout: post
status: publish
published: true
title: Шаблоны проектирования для новичков
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
excerpt: "Если вы когда-либо интересовались, что представляют собой шаблоны проектирования,
  то добро пожаловать. В этой статье я расскажу, что это такое, зачем они нужны, как
  их использовать, и приведу примеры наиболее распространенных шаблонов на PHP."
wordpress_id: 47938
wordpress_url: http://devdocs.ru/?p=47938
date: '2015-11-20 20:32:02 +0200'
date_gmt: '2015-11-20 20:32:02 +0200'
categories:
- Без рубрики
- PHP
- Проектирование
- Интересные ссылки
tags:
- php
- design
- ui
comments: []
---
<p>Если вы когда-либо интересовались, что представляют собой шаблоны проектирования, то добро пожаловать. В этой статье я расскажу, что это такое, зачем они нужны, как их использовать, и приведу примеры наиболее распространенных шаблонов на PHP.</p>
<h2>Что такое шаблоны проектирования?</h2>

<p><strong>Шаблоны проектирования</strong> - это проверенные и готовые к использованию решения часто возникающих в повседневном программировании задач. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее. <strong>Шаблон проектирования</strong>, подходящий под задачу, реализуется в каждом конкретном случае. Кроме того, он не зависит от языка программирования. Хороший шаблон легко реализуется в большинстве, если не во всех языках, в зависимости от выразительных средств языка. Следует, однако, помнить, что такой шаблон, будучи примененным неправильно или к неподходящей задаче, может принести немало проблем. Тем не менее, правильно примененный шаблон поможет решить задачу легко и просто.

<h3>Существует три типа шаблонов:</h3>
<p><strong>Структурные</strong> шаблоны определяют отношения между классами и объектами, позволяя им работать совместно.</p>
<p><strong>Порождающие</strong> шаблоны предоставляют механизмы инициализации, позволяя создавать объекты удобным способом.</p>
<p><strong>Поведенческие</strong> шаблоны используются для того, чтобы упростить взаимодействие между сущностями.</p>

<h2>Зачем нужны шаблоны проектирования?</h2>
<p><strong>Шаблон проектирования</strong>, по своей сути, это продуманное решение той или иной задачи. Если вы столкнулись с известной задачей, почему бы не использовать готовое решение, проверенное опытом?</p>

<h3>Пример</h3>
<p>Давайте представим, что вам необходимо объединить два класса, которые выполняют различные операции в зависимости от ситуации. Эти классы интенсивно используются существующей системой, что не позволяет удалить один из них и добавить его функциональность во второй. Кроме того, изменение кода потребует его тщательного тестирования, поскольку такой рефакторинг ведет к неизбежным ошибкам. Вместо этого вы можете реализовать шаблоны "Стратегия" и "Адаптер" и с их помощью решить задачу.</p>

<pre><code>class StrategyAndAdapterExampleClass {
        private $_class_one;
        private $_class_two;
        private $_context;
 
        public function __construct( $context ) {
                        $this->_context = $context;
        }
 
        public function operation1() {
                if( $this->_context == "context_for_class_one" ) {
                        $this->_class_one->operation1_in_class_one_context();
                } else ( $this->_context == "context_for_class_two" ) {
                        $this->_class_two->operation1_in_class_two_context();
                }
        }
}</code></pre>

<p>Просто, не правда ли? Давайте посмотрим поближе на шаблон "<em>Стратегия</em>".</p>
<hr />
<h2>Шаблон "Стратегия"</h2>
<p><strong>Стратегия</strong> - поведенческий шаблон, который позволяет выбрать поведение программы в процессе выполнения в зависимости от контекста путем инкапсуляции нескольких алгоритмов в разных классах.</p>
<p>В примере выше выбор стратегии основан на значении переменной <em>$context</em>, которое было в момент создания объекта. Если значение было <em>"context_for_class_one"</em>, программа будет использовать класс <em>class_one</em>. И наоборот.</p>

<h3>Хорошо, но где это можно использовать?</h3>
<p>Представьте, что вы разрабатываете класс, который может создать или обновить запись в базе данных. В обоих случаях входные параметры будут одни и те же (имя, адрес, номер телефона и т.п.), но, в зависимости от ситуации, он будет должен использовать различные функции для обновления и создания записи. Можно каждый раз переписывать условие <tt>if/else</tt>, а можно создать один метод, который будет принимать контекст:</p>
<pre><code>class User {
 
        public function CreateOrUpdate($name, $address, $mobile, $userid = null)
        {
                if( is_null($userid) ) {
                        // пользователя не существует, создаем запись
                } else {
                        // запись есть, обновляем ее
                }
        }
}</code></pre>
<p>Обычно шаблон "<em>Стратегия</em>" подразумевает инкапсуляцию алгоритмов в классы, но в данном случае это излишне. Помните, что вы не обязаны следовать шаблону слово в слово. Любые варианты допустимы, если они решают задачу и соответствуют концепции.</p>
<hr />
<h2>Шаблон "Адаптер"</h2></p>
<p><strong>Адаптер</strong> - структурный шаблон, который позволяет использовать класс, реализующий нужные функции, но имеющий неподходящий интерфейс.</p>
<p>Также он позволяет изменить некоторые входные данные для совместимости с интерфейсом внутреннего класса.</p>

<h3>Как его использовать?</h3>
<p>Другое название адаптера - "<em>Обертка</em>". Он "оборачивает" новый интерфейс вокруг класса для его использования. </p>
<p>Классический пример: вам надо создать класс предметной модели, имея классы объектов в базе данных. Вместо того, чтобы обращаться к табличным классам напрямую и вызывать их методы по одному, вы можете инкапсулировать вызовы этих методов в одном методе в адаптере. Это не только позволит повторно использовать набор операций, но и избавит вас от постоянного переписывания большого количества кода, если вам потребуется выполнить тот же набор действий в другом месте.</p>
<p>Сравните два примера.</p>

<h4>Без адаптера</h4>
<pre><code>$user = new User();
$user->CreateOrUpdate( // параметры );
 
$profile = new Profile();
$profile->CreateOrUpdate( // параметры );</code></pre>

<p>Если нам придется использовать такой код повторно, мы будем вынуждены переписывать все это заново.</p>

<h4>С использованием адаптера</h4>
<pre><code>class Account()
{
        public function NewAccount( // параметры )
        {
                $user = new User();
                $user->CreateOrUpdate( // часть параметров );
 
                $profile = new Profile();
                $profile->CreateOrUpdate( // часть параметров );
        }
}

$account_domain = new Account();
$account_domain->NewAccount( // параметры );</code></pre>

<p>Теперь мы можем использовать класс <em>Account</em> каждый раз и, кроме того, мы можем добавить в него дополнительные функции.</p>
<hr />
<h2>Шаблон "Метод-фабрика"</h2>
<p><strong>Фабрика</strong> - порождающий шаблон, который представляет собой класс с методом для создания различных объектов.</p>
<p>Основная цель этого шаблона - инкапсулировать процедуру создания различных классов в одну функциию, которая в зависимости от переданного ей контекста возвращает необходимый объект.</p>

<h3>Как его использовать?</h3>
<p>Фабрика обычно используется для создания различных вариантов базового класса. Допустим, у вас есть класс кнопки <em>Button</em> и три варианта <em>ImageButton</em>, <em>InputButton</em> и <em>FlashButton</em>. С помощью фабрики вы можете создавать различные варианты кнопок в зависимости от ситуации.</p>
<p>Сначала создадим три класса:</p>
<pre><code>abstract class Button {
        protected $_html;
 
        public function getHtml()
        {
                return $this->_html;
        }
}
 
class ImageButton extends Button {
        protected $_html = "..."; // HTML-код кнопки-картинки
}
 
class InputButton extends Button {
        protected $_html = "..."; // HTML-код обычной кнопки ();
}
 
class FlashButton extends Button {
        protected $_html = "..."; // HTML-код Flash-кнопки
}</code></pre>

<p>Теперь мы можем написать нашу фабрику:</p>

<pre><code>class ButtonFactory
{
    public static function createButton($type)
    {
        $baseClass = 'Button';
        $targetClass = ucfirst($type).$baseClass;
 
        if (class_exists($targetClass) && is_subclass_of($targetClass, $baseClass)) {
            return new $targetClass;
        } else {
            throw new Exception("The button type '$type' is not recognized.");
        }
    }
}</code></pre>
<p>и использовать ее:</p>
<pre><code>$buttons = array('image','input','flash');
foreach($buttons as $b) {
    echo ButtonFactory::createButton($b)->getHtml()
}</code></pre>
<p>На выходе должен получиться HTML со всеми типами кнопок. Таким образом мы получили возможность указать, кнопку какого типа мы хотим получить, и использовать код повторно.</p>

<hr />
<h2>Шаблон "Декоратор"</h2></p>
<p><strong>Декоратор</strong> - это структурный шаблон, который позволяет добавить новое поведение объекту в процессе выполнения программы в зависимости от ситуации.</p>
<p>Цель - в расширении поведения конкретного объекта без необходимости изменять поведение базового класса. Это позволит использовать несколько декораторов одновременно. Этот шаблон - альтернатива наследованию. В отличие от наследования, декоратор добавляет поведение в процессе выполнения программы.</p>
<p>Для реализации декоратора нам понадобится:</p>
<ol>
<li>Унаследовать класс-декоратор от базового.</li>
<li>Добавить поле со ссылкой на базовый класс в декоратор.</li>
<li>Передать ссылку на декорируемый объект в конструктор декоратора.</li>
<li>Перенаправить методы из декоратора на декорируемый объект.</li>
<li>Переопределить методы в декораторе, поведение которых необходимо изменить.</li>
</ol></p>
<h3>Как его использовать?</h3>
<p>Предположим, что у нас есть объект, который должен иметь определенное поведение в определенной ситуации. Например, у нас есть HTML-ссылка для выхода из аккаунта, которая должна по-разному показываться в зависимости от того, на какой странице мы находимся. Это тот самый случай, когда нам помогут декораторы.</p>
<p>Сначала определимся, какие "декорации" нам нужны:</p>
<ul>
<li>Если мы на заглавной странице и вошли в аккаунт, ссылка должна быть в a-теге.</li>
<li>Если мы на любой другой странице и вошли в аккаунт, ссылка должна быть подчеркнутой.</li>
<li>Если мы вошли в аккаунт, ссылка должна быть в <code></code>-теге.</li>
</ul>
<p>Теперь мы можем написать сами декораторы:</p>
 
<pre><code>class HtmlLinks {
        // методы для работы с любой HTML-ссылкой
}
 
class LogoutLink extends HtmlLinks {
        protected $_html;
 
        public function __construct() {
                $this->_html = "Logout";
        }
 
        public function setHtml($html)
        {
                $this->_html = $html;
        }
 
        public function render()
        {
                echo $this->_html;
        }
}
 
class LogoutLinkH2Decorator extends HtmlLinks {
        protected $_logout_link;
 
        public function __construct( $logout_link )
        {
                $this->_logout_link = $logout_link;
                $this->setHtml("". $this->_html . "");
        }
 
        public function __call( $name, $args )
        {
                $this->_logout_link->$name($args[0]);
        }
}
 
class LogoutLinkUnderlineDecorator extends HtmlLinks {
        protected $_logout_link;
 
        public function __construct( $logout_link )
        {
                $this->_logout_link = $logout_link;
                $this->setHtml("" . $this->_html . "");
        }
 
        public function __call( $name, $args )
        {
                $this->_logout_link->$name($args[0]);
        }
}
 
class LogoutLinkStrongDecorator extends HtmlLinks {
        protected $_logout_link;
 
        public function __construct( $logout_link )
        {
                $this->_logout_link = $logout_link;
                $this->setHtml("" . $this->_html . "");
        }
 
        public function __call( $name, $args )
        {
                $this->_logout_link->$name($args[0]);
        }
}</code></pre>
<p>Теперь мы можем использовать их так:</p>
<pre><code>$logout_link = new LogoutLink();
 
if( $is_logged_in ) {
        $logout_link = new LogoutLinkStrongDecorator($logout_link);
}
 
if( $in_home_page ) {
        $logout_link = new LogoutLinkH2Decorator($logout_link);
} else {
        $logout_link = new LogoutLinkUnderlineDecorator($logout_link);
}
$logout_link->render();</code></pre>

<p>Обратите внимание, как можно использовать несколько декораторов на одном объекте. Все они используют функцию <em>__call</em> для вызова оригинального метода. Если мы войдем в аккаунт и перейдем на заглавную страницу, результат будет такой:</p>
<pre><code>< a href="/logout.php">logout< /a></code></pre>
<hr />
<h2>Шаблон "Одиночка"</h2>
<p><strong>Одиночка</strong> — порождающий шаблон, который позволяет убедиться, что в процессе выполнения программы создается только один экземпляр класса с глобальным доступом.</p>
<p>Его можно использовать как точку "координации" для других объектов, поскольку поля "Одиночки" будут одинаковы для всех, кто его вызывает.</p>

<h3>Как его использовать?</h3>

<p>Если вам необходимо передавать определенный экземпляр из класса в класс, вы можете передавать его каждый раз через конструктор или использовать "<strong>Одиночку</strong>". Допустим, у вас есть класс Session, который содержит данные о текущей сессии. Поскольку сессия инициализируется только один раз, мы можем реализовать его так:</p>

<pre><code>class Session
{
        private static $instance;
 
        public static function getInstance()
        {
                if( is_null(self::$instance) ) {
                        self::$instance = new self();
                }
                return self::$instance;
        }
 
        private function __construct() { }
 
        private function __clone() { }
 
        //  прочие методы сессии
        ...
        ...
        ...
}
 
// get a session instance
$session = Session::getInstance();</code></pre>

<p>Теперь мы можем получить доступ к сессии из различных участков кода, даже из других классов. Метод <em>getInstance</em> всегда будет возвращать одну и ту же сессию.</p>

<h2>Заключение</h2>
В этой статье мы рассмотрели только наиболее часто встречающиеся шаблоны из множества. Если вы хотите узнать больше о шаблонах проектирования, вы найдете достаточно информации на <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Википедии</a>. Для более полной информации обратите внимание на знаменитую книгу <a href="http://www.ozon.ru/context/detail/id/2457392/">"Приемы объектно-ориентированного проектирования"</a> "Банды четырех".</p>
<p>И последнее: при использовании того или иного шаблона убедитесь, что вы решаете задачу правильным способом. Как уже упоминалось, при неправильном использовании шаблоны проектирования могут доставить больше проблем, чем решить. Но при правильном - их пользу нельзя переоценить.</p>
<p><suem>Перевод статьи <a href="http://code.tutsplus.com/articles/a-beginners-guide-to-design-patterns--net-12752">"A Beginner's Guide to Design Patterns?"</a></suem></p>