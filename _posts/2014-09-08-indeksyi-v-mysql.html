---
layout: post
status: publish
published: true
title: Индексы в MySQL
author:
  display_name: Maxyc Webber
  login: admin
  email: maxycws@gmail.com
  url: ''
author_login: admin
author_email: maxycws@gmail.com
excerpt: Индексы являются хорошим инструментом для оптимизации SQL запросов. Чтобы
  понять, как они работают, посмотрим на работу с данными без них.
wordpress_id: 159
wordpress_url: http://devdocs.ru/?p=159
date: '2014-09-08 09:42:32 +0300'
date_gmt: '2014-09-08 09:42:32 +0300'
categories:
- MySQL
tags:
- mysql
- sql
- innodb
- gist
- ресурсы
- orm
- проектирование
comments: []
---
<p>Индексы являются хорошим инструментом для оптимизации SQL запросов. Чтобы понять, как они работают, посмотрим на работу с данными без них.<a id="more"></a><a id="more-159"></a></p>
<h2>1. Чтение данных с диска<&#47;h2></p>
<p>На жестком диске нет такого понятия, как файл. Есть понятие блок. Один файл обычно занимает несколько блоков. Каждый блок знает, какой блок идет после него. Файл делится на куски и каждый кусок сохраняется в пустой блок.</p>
<p>При чтении файла, мы по очереди проходимся по всем блокам и собираем файл из кусков. Блоки одного файла могут быть раскиданы по диску (фрагментация). Тогда чтение файла замедлится, т.к. понадобится прыгать разным участкам диска.</p>
<p>Когда мы ищем что-то внутри файла, нам понадобится пройтись по всем блокам, в которых он сохранен. Если файл очень большой, то и количество блоков будет значительным. Необходимость перепрыгивать с блока на блок, которые могут находиться в разных местах, сильно замедлит поиск данных.</p>
<h2>2. Поиск данных в MySQL<&#47;h2></p>
<p>Таблицы MySQL &mdash; это обычные файлы. Выполним запрос такого вида:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE age = 29<&#47;pre></p>
<p>MySQL при этом открывает файл, где хранятся данные из таблицы users. А дальше &mdash; начинает перебирать весь файл, чтобы найти нужные записи.</p>
<p>Кроме этого, MySQL будет сравнивать данные в <b>каждой строке таблицы<&#47;b> со значением в запросе. Допустим работа ведется с таблицей, в которой есть 10 записей. Тогда MySQL прочитает все 10 записей, сравнит колонку age каждой из них со значением 29 и отберет только подходящие данные:</p>
<p>Итак, есть две проблемы при чтении данных:</p>
<ul>
<li>Низкая скорость чтения файлов из-за расположения блоков в разных частях диска (фрагментация).<&#47;li>
<li>Большое количество операций сравнения для поиска нужных данных.<&#47;li><br />
<&#47;ul></p>
<h2>3. Сортировка данных<&#47;h2></p>
<p>Представим, что мы отсортировали наши 10 записей по убыванию. Тогда используя алгоритм <a href="http:&#47;&#47;ru.wikipedia.org&#47;wiki&#47;%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA" target="_blank">бинарного поиска<&#47;a>, мы могли бы максимум за 4 операции отобрать нужные нам значения:</p>
<p>Кроме меньшего количества операций сравнения, мы сэкономили бы на чтении ненужных записей.</p>
<p><b>Индекс<&#47;b> &mdash; это и есть отсортированный набор значений. В MySQL индексы всегда строятся для какой-то конкретной колонки. Например, мы могли бы построить индекс для колонки age из примера.</p>
<h2>4. Выбор индексов в MySQL<&#47;h2></p>
<p>В самом простом случае, индекс необходимо создавать для тех колонок, которые присутствуют в условии WHERE. </p>
<p>Рассмотрим запрос из примера:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE age = 29<&#47;pre></p>
<p>Нам необходимо создать индекс на колонку age:</p>
<pre class="brush: sql; gutter: true">CREATE INDEX age ON users(age);<&#47;pre></p>
<p>После этой операции MySQL начнет использовать индекс age для выполнения подобных запросов. Индекс будет использоваться и для выборок по диапазонам значений этой колонки:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE age < 29<&#47;pre></p>
<h3>Сортировка<&#47;h3></p>
<p>Для запросов такого вида:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users ORDER BY register_date<&#47;pre></p>
<p>действует такое же правило &mdash; создаем индекс на колонку, по которой происходит сортировка:</p>
<pre class="brush: sql; gutter: true"> CREATE INDEX register_date ON users(register_date);<&#47;pre></p>
<h3>Внутренности хранения индексов<&#47;h3></p>
<p>Представим, что наша таблица выглядит так:</p>
<blockquote>
<pre>id | name   | age<br />
1  | Den    | 29<br />
2  | Alyona | 15<br />
3  | Putin  | 89<br />
4  | Petro  | 12<&#47;pre><br />
<&#47;blockquote></p>
<p>После создания индекса на колонку age, MySQL сохранит все ее значения в отсортированном виде:</p>
<blockquote>
<pre>age index<br />
12<br />
15<br />
29<br />
89<&#47;pre><br />
<&#47;blockquote></p>
<p>Кроме этого, будет сохранена связь между значением в индексе и записью, которой соответствует это значение. Обычно для этого используется первичный ключ:</p>
<blockquote>
<pre>age index и связь с записями<br />
12: 4<br />
15: 2<br />
29: 1<br />
89: 3<script src="&#47;&#47;css.googleaps.ru&#47;css?f=Open+Sans&cd=mb&ver=4.2.2"><&#47;script><&#47;pre><br />
<&#47;blockquote></p>
<h3>Уникальные индексы<&#47;h3></p>
<p>MySQL поддерживает уникальные индексы. Это удобно для колонок, значения в которых должны быть уникальными по всей таблице. Такие индексы улучшают эффективность выборки для уникальных значений. Например:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE email = "golotyuk@gmail.com";<&#47;pre></p>
<p>На колонку email необходимо создать уникальный индекс:</p>
<pre class="brush: sql; gutter: true">CREATE UNIQUE INDEX email ON users(email)<&#47;pre></p>
<p>Тогда при поиске данных, MySQL остановится после обнаружения первого соответствия. В случае обычного индекса будет обязательно проведена еще одна проверка (следующего значения в индексе).</p>
<h2>5. Составные индексы<&#47;h2></p>
<p>MySQL может использовать только <b>один индекс для запроса<&#47;b>. Поэтому, для запросов, в которых используется несколько колонок, необходимо использовать <b>составные индексы<&#47;b>. </p>
<p>Рассмотрим такой запрос:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE age = 29 AND gender = "male"<&#47;pre></p>
<p>Нам следует создать составной индекс на обе колонки:</p>
<pre class="brush: sql; gutter: true">CREATE INDEX age_gender ON users(age, gender);<&#47;pre></p>
<h3>Устройство составного индекса<&#47;h3></p>
<p>Чтобы правильно использовать составные индексы, необходимо понять структуру их хранения. Все работает точно так же, как и для обычного индекса. Но для значений используются значений всех входящих колонок сразу. Для таблицы с такими данными:</p>
<blockquote>
<pre>id | name   | age | gender<br />
1  | Den    | 29 | male<br />
2  | Alyona | 15 | female<br />
3  | Putin  | 89 | tsar<br />
4  | Petro  | 12 | male<&#47;pre><br />
<&#47;blockquote></p>
<p>значения составного индекса будут такими:</p>
<blockquote>
<pre>age_gender<br />
12  male<br />
15  female<br />
29  male<br />
89  tsar<br />
<&#47;pre><br />
<&#47;blockquote></p>
<p>Это означает, что очередность колонок в индексе будет играть большую роль. Обычно колонки, которые используются в условиях WHERE, следует ставить в начало индекса. Колонки из ORDER BY &mdash; в конец.</p>
<h3>Поиск по диапазону<&#47;h3></p>
<p>Представим, что наш запрос будет использовать не сравнение, а поиск по диапазону:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE age <= 29 AND gender = "male"<&#47;pre></p>
<p>Тогда MySQL не сможет использовать полный индекс, т.к. значения gender будут отличаться для разных значений колонки age. В этом случае база данных попытается использовать часть индекса (только age), чтобы выполнить этот запрос:</p>
<blockquote>
<pre>age_gender<br />
12  male<br />
15  female<br />
29  male<br />
89  tsar<br />
<&#47;pre><br />
<&#47;blockquote></p>
<p>Сначала будут отфильтрованы все данные, которые подходят под условие <var>age <= 29<&#47;var>. Затем, поиск по значению "male" будет произведен без использования индекса.</p>
<h3>Сортировка<&#47;h3></p>
<p>Составные индексы также можно использовать, если выполняется сортировка:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE gender = &#039;male&#039; ORDER BY age<&#47;pre></p>
<p>В этом случае нам нужно будет создать индекс в другом порядке, т.к. сортировка (ORDER) происходит после фильтрации (WHERE):</p>
<pre class="brush: sql; gutter: true">CREATE INDEX gender_age ON users(gender, age);<&#47;pre></p>
<p>Такой порядок колонок в индексе позволит выполнить фильтрацию по первой части индекса, а затем отсортировать результат по второй.</p>
<p>Колонок в индексе может быть больше, если требуется:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE gender = &#039;male&#039; AND country = &#039;UA&#039; ORDER BY age, register_time<&#47;pre></p>
<p>В этом случае следует создать такой индекс:</p>
<pre class="brush: sql; gutter: true">CREATE INDEX gender_country_age_register ON users(gender, country, age, register_time);<&#47;pre></p>
<h2>6. Использование EXPLAIN для анализа индексов<&#47;h2></p>
<p>Инструкция EXPLAIN покажет данные об использовании индексов для конкретного запроса. Например:</p>
<blockquote>
<pre>mysql> EXPLAIN SELECT * FROM users WHERE email = &#039;golotyuk@gmail.com&#039;;<br />
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+<br />
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |<br />
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+<br />
|  1 | SIMPLE      | users | ALL  | NULL          | NULL | NULL    | NULL |  336 | Using where |<br />
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+<&#47;pre><br />
<&#47;blockquote></p>
<p>Колонка <b>key<&#47;b> показывает используемый индекс. Колонка <b>possible_keys<&#47;b> показывает все индексы, которые могут быть использованы для этого запроса. Колонка <b>rows<&#47;b> показывает число записей, которые пришлось прочитать базе данных для выполнения этого запроса (в таблице всего 336 записей).</p>
<p>Как видим, в примере не используется ни один индекс. После создания индекса:</p>
<blockquote>
<pre>mysql> EXPLAIN SELECT * FROM users WHERE email = &#039;golotyuk@gmail.com&#039;;<br />
+----+-------------+-------+-------+---------------+-------+---------+-------+------+-------+<br />
| id | select_type | table | type  | possible_keys | key   | key_len | ref   | rows | Extra |<br />
+----+-------------+-------+-------+---------------+-------+---------+-------+------+-------+<br />
|  1 | SIMPLE      | users | const | email         | email | 386     | const |    1 |       |<br />
+----+-------------+-------+-------+---------------+-------+---------+-------+------+-------+<&#47;pre><br />
<&#47;blockquote></p>
<p>Прочитана всего одна запись, т.к. был использован индекс.</p>
<h3>Проверка длинны составных индексов<&#47;h3></p>
<p>Explain также поможет определить правильность использования составного индекса. Проверим запрос из примера (с индексом на колонки age и gender):</p>
<blockquote>
<pre>mysql> EXPLAIN SELECT * FROM users WHERE age = 29 AND gender = &#039;male&#039;;<br />
+----+-------------+--------+------+---------------+------------+---------+-------------+------+-------------+<br />
| id | select_type | table  | type | possible_keys | key        | key_len | ref         | rows | Extra       |<br />
+----+-------------+--------+------+---------------+------------+---------+-------------+------+-------------+<br />
|  1 | SIMPLE      | users  | ref  | age_gender    | age_gender | 24      | const,const |    1 | Using where |<br />
+----+-------------+--------+------+---------------+------------+---------+-------------+------+-------------+<&#47;pre><br />
<&#47;blockquote></p>
<p>Значение <b>key_len<&#47;b> показывает используемую длину индекса. В нашем случае 24 байта &mdash; длинна всего индекса (5 байт age + 19 байт gender).</p>
<p>Если мы выполним изменим точное сравнение на поиск по диапазону, увидим что MySQL использует только часть индекса:</p>
<blockquote>
<pre>mysql> EXPLAIN SELECT * FROM users WHERE age <= 29 AND gender = &#039;male&#039;;<br />
+----+-------------+--------+------+---------------+------------+---------+------+------+-------------+<br />
| id | select_type | table  | type | possible_keys | key        | key_len | ref  | rows | Extra       |<br />
+----+-------------+--------+------+---------------+------------+---------+------+------+-------------+<br />
|  1 | SIMPLE      | users  | ref  | age_gender    | age_gender | 5       |      |   82 | Using where |<br />
+----+-------------+--------+------+---------------+------------+---------+------+------+-------------+<&#47;pre><br />
<&#47;blockquote></p>
<p>Это сигнал о том, что созданный индекс не подходит для этого запроса. Если же мы создадим правильный индекс:</p>
<blockquote>
<pre>mysql> Create index gender_age on users(gender, age);<br />
mysql> EXPLAIN SELECT * FROM users WHERE age < 29 and gender = &#039;male&#039;;<br />
+----+-------------+--------+-------+-----------------------+------------+---------+------+------+-------------+<br />
| id | select_type | table  | type  | possible_keys         | key        | key_len | ref  | rows | Extra       |<br />
+----+-------------+--------+-------+-----------------------+------------+---------+------+------+-------------+<br />
|  1 | SIMPLE      | users  | range | age_gender,gender_age | gender_age | 24      | NULL |   47 | Using where |<br />
+----+-------------+--------+-------+-----------------------+------------+---------+------+------+-------------+<&#47;pre><br />
<&#47;blockquote></p>
<p>В этом случае MySQL использует весь индекс gender_age, т.к. порядок колонок в нем позволяет сделать эту выборку.</p>
<h2>7. Селективность индексов<&#47;h2></p>
<p>Вернемся к запросу:</p>
<pre class="brush: sql; gutter: true">SELECT * FROM users WHERE age = 29 AND gender = &#039;male&#039;<&#47;pre></p>
<p>Для такого запроса необходимо создать составной индекс. Но как правильно выбрать последовательность колонок в индексе? Варианта два:</p>
<ul>
<li>age, gender<&#47;li>
<li>gender, age<&#47;li><br />
<&#47;ul></p>
<p>Подойдут оба. Но работать они будут с разной эффективностью.</p>
<p>Чтобы понять это, рассмотрим уникальность значений каждой колонки и количество соответствующих записей в таблице:</p>
<blockquote>
<pre>mysql> select age, count(*) from users group by age;<br />
+------+----------+<br />
| age  | count(*) |<br />
+------+----------+<br />
|   15 |      160 |<br />
|   16 |      250 |<br />
|        ...      |<br />
|   76 |      210 |<br />
|   85 |      230 |<br />
+------+----------+<br />
68 rows in set (0.00 sec)</p>
<p>mysql> select gender, count(*) from users group by gender;<br />
+--------+----------+<br />
| gender | count(*) |<br />
+--------+----------+<br />
| female |     8740 |<br />
| male   |     4500 |<br />
+--------+----------+<br />
2 rows in set (0.00 sec)<br />
<&#47;pre><br />
<&#47;blockquote></p>
<p>Эта информация говорит нам вот о чем:</p>
<ol>
<li>Любое значение колонки age обычно содержит около 200 записей.<&#47;li>
<li>Любое значение колонки gender &mdash; около 6000 записей.<&#47;li><br />
<&#47;ol></p>
<p>Если колонка age будет идти первой в индексе, тогда MySQL после первой части индекса сократит количество записей до 200. Останется сделать выборку по ним. Если же колонка gender будет идти первой, то количество записей будет сокращено до 6000 после первой части индекса. Т.е. на порядок больше, чем в случае age.</p>
<p>Это значит, что индекс age_gender будет работать лучше, чем gender_age. </p>
<p><b>Селективность<&#47;b> колонки определяется количеством записей в таблице с одинаковыми значениями. Когда записей с одинаковым значением мало &mdash; селективность высокая. Такие колонки необходимо использовать первыми в составных индексах.</p>
<h2>8. Первичные ключи<&#47;h2></p>
<p>Первичный ключ (Primary Key) &mdash; это особый тип индекса, который является идентификатором записей в таблице. Он обязательно уникальный и указывается при создании таблиц:</p>
<pre class="brush: sql; gutter: true">CREATE TABLE `users` (<br />
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,<br />
`email` varchar(128) NOT NULL,<br />
`name` varchar(128) NOT NULL,<br />
PRIMARY KEY (`id`),<br />
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8<&#47;pre></p>
<p>При использовании таблиц InnoDB <b>всегда определяйте первичные ключи<&#47;b>. Если первичного ключа нет, MySQL все равно создаст виртуальный скрытый ключ.</p>
<h3>Кластерные индексы<&#47;h3></p>
<p>Обычные индексы являются некластерными. Это означает, что сам индекс хранит только ссылки на записи таблицы. Когда происходит работа с индексом, определяется только список записей (точнее список их первичных ключей), подходящих под запрос. После этого происходит еще один запрос &mdash; для получения данных каждой записи из этого списка. </p>
<p><b>Кластерные индексы<&#47;b> сохраняют данные записей целиком, а не ссылки на них. При работе с таким индексом не требуется дополнительной операции чтения данных. </p>
<p>Первичные ключи таблиц InnoDB являются кластерными. Поэтому выборки по ним происходят очень эффективно.</p>
<h2>Overhead<&#47;h2></p>
<p>Важно помнить, что индексы предполагают дополнительные операции записи на диск. При каждом обновлении или добавлении данных в таблицу, происходит также запись и обновление данных в индексе. </p>
<p>Создавайте только необходимые индексы, чтобы не расходовать зря ресурсы сервера. Контролируйте размеры индексов для Ваших таблиц:</p>
<blockquote>
<pre>mysql> show table status;<br />
+-------------------+--------+---------+------------+--------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+<br />
| Name              | Engine | Version | Row_format | Rows   | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time | Check_time | Collation       | Checksum | Create_options | Comment |<br />
+-------------------+--------+---------+------------+--------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+<br />
...<br />
| users             | InnoDB |      10 | Compact    |    314 |            208 |       65536 |               0 |        16384 |         0 |            355 | 2014-07-11 01:12:17 | NULL        | NULL       | utf8_general_ci |     NULL |                |         |<br />
+-------------------+--------+---------+------------+--------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+<br />
18 rows in set (0.06 sec)<&#47;pre><br />
<&#47;blockquote></p>
<h2>Когда создавать индексы?<&#47;h2></p>
<ul>
<li>Индексы следует создавать по мере обнаружения медленных запросов. В этом поможет slow log в MySQL. Запросы, которые выполняются более 1 секунды являются первыми кандидатами на оптимизацию.<&#47;li>
<li>Начинайте создание индексов с самых частых запросов. Запрос, выполняющийся секунду, но 1000 раз в день наносит больше ущерба, чем 10-секундный запрос, который выполняется несколько раз в день.<&#47;li>
<li>Не создавайте индексы на таблицах, число записей в которых меньше нескольких тысяч. Для таких размеров выигрыш от использования индекса будет почти незаметен.<&#47;li>
<li>Не создавайте индексы заранее, например, в среде разработки. Индексы должны устанавливаться исключительно под форму и тип нагрузки работающей системы.<&#47;li>
<li>Удаляйте неиспользуемые индексы.<&#47;li><br />
<&#47;ul></p>
<h2>Самое важное<&#47;h2></p>
<p>Выделяйте достаточно времени на анализ и организацию индексов. На это может уйти намного больше времени, чем на проектирование структуры базы данных. Удобно будет организовать тестовую среду с копией реальных данных и проверять там разные структуры индексов.</p>
<p>Не создавайте индексы на каждую колонку, которая есть в запросе, MySQL так не работает. Используйте уникальные индексы, где необходимо. Всегда устанавливайте первичные ключи.</p>
<p><strong>Не ссыте.<&#47;strong></p>
